import TourCatData.DatabaseManager;
import TourCatData.FileManager;
import TourCatGUI.HomePage;
import TourCatService.LocationService;

import java.io.IOException;

public class main {
    public static void main(String[] args) throws IOException {

        FileManager fileManager = FileManager.getInstance();
        DatabaseManager databaseManager = new DatabaseManager(fileManager.getDatabaseFile());

        LocationService service = new LocationService(databaseManager, fileManager);

        HomePage homePage = new HomePage(null, service);

        System.out.println("Startup!!!!");
    }
}
import TourCatData.DatabaseManager;
import TourCatData.FileManager;
import TourCatGUI.HomePage;
import TourCatService.LocationService;

import javax.swing.*;
import java.io.IOException;


public class MainApplication {


    public static void main(String[] args) {

        FileManager fileManager = FileManager.getInstance(true);
        DatabaseManager databaseManager = null;
        try {
            databaseManager = new DatabaseManager(fileManager.getDatabaseFile());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        LocationService service = new LocationService(databaseManager, fileManager);

        HomePage homePage = new HomePage(null, service);

        System.out.println("Startup!!!!");
    }
}
package TourCatData;

import com.opencsv.*;
import com.opencsv.exceptions.CsvException; // Use CsvException for broader CSV errors

import java.io.*;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.OptionalInt; // Good for returning optional numeric results

/**
 * Manages interaction with a location database stored in a CSV file.
 * Provides methods to read, add, delete, and query location records.
 * Each instance operates on a specific database file.
 *
 * CSV Structure Expected:
 * - Column 0: ID (String, unique, typically numeric format like "00001")
 * - Column 1: Name (String)
 * - Column 2: City (String)
 * - Column 3: Province (String)
 * - Column 4: Category (String)
 *
 * Dependencies: OpenCSV library.
 *
 * Error Handling: Methods throw IOExceptions or CsvExceptions on failure.
 *
 * Author: Garrett (Refactored by AI Assistant)
 * Version: 2.0
 * Date: 2023-10-27 (Approx. refactor date)
 */
public class DatabaseManager {

    // --- Constants for CSV Column Indices ---
    private static final int ID_COLUMN = 0;
    private static final int NAME_COLUMN = 1;
    private static final int CITY_COLUMN = 2;
    private static final int PROVINCE_COLUMN = 3;
    private static final int CATEGORY_COLUMN = 4;
    // Add more if needed, ensure this matches your actual file structure

    private final File databaseFile;
    private final CSVParser csvParser; // Reusable parser configuration

    /**
     * Creates a DatabaseManager instance for the specified CSV file.
     *
     * @param databaseFile The CSV file to manage. Must not be null.
     * @throws IllegalArgumentException if databaseFile is null or not a file.
     * @throws IOException if the file cannot be created or accessed appropriately.
     */
    public DatabaseManager(File databaseFile) throws IOException {
        if (databaseFile == null) {
            throw new IllegalArgumentException("Database file cannot be null.");
        }
        // Ensure the directory exists
        File parentDir = databaseFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            if (!parentDir.mkdirs()) {
                throw new IOException("Could not create parent directory: " + parentDir.getAbsolutePath());
            }
        }
        // Ensure the file exists (create if not) - Optional: you might want creation handled elsewhere
        if (!databaseFile.exists()) {
            try {
                if (databaseFile.createNewFile()) {
                    // Optionally write header row if creating a new file
                    writeHeaderIfNotPresent();
                    System.out.println("Created new database file: " + databaseFile.getAbsolutePath());
                } else {
                    throw new IOException("Could not create database file: " + databaseFile.getAbsolutePath());
                }
            } catch(SecurityException se) {
                throw new IOException("Security exception creating file: " + databaseFile.getAbsolutePath(), se);
            }
        }
        if (!databaseFile.isFile()) {
            throw new IllegalArgumentException("Database path does not point to a valid file: " + databaseFile.getAbsolutePath());
        }

        this.databaseFile = databaseFile;

        // Configure the parser once - assuming standard CSV, no quotes needed based on original code
        this.csvParser = new CSVParserBuilder()
                .withSeparator(CSVWriter.DEFAULT_SEPARATOR)
                // .withQuoteChar(CSVWriter.NO_QUOTE_CHARACTER) // Let parser handle quotes if they exist
                .build();
    }

    /**
     * Writes the header row if the database file is empty or newly created.
     * @throws IOException if writing fails.
     */
    private void writeHeaderIfNotPresent() throws IOException {
        if (databaseFile.length() == 0) { // Check if file is empty
            try (ICSVWriter writer = createCsvWriter(false)) { // false = don't append
                writer.writeNext(new String[]{"ID", "Name", "City", "Province", "Category"});
            }
        }
    }


    /**
     * Helper to create a configured CSVWriter.
     *
     * @param append true to append to the file, false to overwrite.
     * @return An configured ICSVWriter instance.
     * @throws IOException If the writer cannot be created.
     */
    private ICSVWriter createCsvWriter(boolean append) throws IOException {
        // Based on original code, NO_QUOTE_CHARACTER was used. Be cautious if data might contain commas.
        // If data can contain commas or quotes, use DEFAULT_QUOTE_CHARACTER.
        return new CSVWriterBuilder(new FileWriter(databaseFile, append))
                .withSeparator(CSVWriter.DEFAULT_SEPARATOR)
                .withQuoteChar(CSVWriter.NO_QUOTE_CHARACTER) // Adjust if needed
                .withEscapeChar(CSVWriter.NO_ESCAPE_CHARACTER) // Adjust if needed
                .withLineEnd(CSVWriter.DEFAULT_LINE_END)
                .build();
    }

    /**
     * Deletes a record from the CSV file based on its unique ID.
     * This is generally safer and more reliable than deleting by name if IDs are unique.
     *
     * @param locationIdToDelete The ID of the location record to delete.
     * @throws IOException  If file reading/writing fails.
     * @throws CsvException If there's an error processing the CSV data.
     * @throws RecordNotFoundException If no record with the specified ID is found.
     */
    public void deleteById(String locationIdToDelete) throws IOException, CsvException, RecordNotFoundException {
        if (locationIdToDelete == null || locationIdToDelete.trim().isEmpty()) {
            throw new IllegalArgumentException("Location ID to delete cannot be null or empty.");
        }

        List<String[]> allRows;
        try (CSVReader reader = new CSVReaderBuilder(new FileReader(databaseFile)).withCSVParser(csvParser).build()) {
            allRows = reader.readAll();
        }

        List<String[]> rowsToWrite = new ArrayList<>();
        boolean found = false;
        int expectedColumnCount = -1; // Track expected columns from header or first row

        for (String[] row : allRows) {
            if (row == null || row.length == 0) continue; // Skip empty lines

            if (expectedColumnCount == -1) {
                expectedColumnCount = row.length; // Set based on first valid row (usually header)
            }

            // Basic validation - Check against ID column
            if (row.length > ID_COLUMN && locationIdToDelete.equals(row[ID_COLUMN])) {
                found = true; // Found the record, don't add it to rowsToWrite
            } else {
                // Check for consistent column count if desired, otherwise just write valid rows
                if(row.length != expectedColumnCount) {
                    System.err.println("Warning: Row with inconsistent column count encountered: " + String.join(",", row));
                    // Decide whether to skip or write these malformed rows
                }
                rowsToWrite.add(row);
            }
        }

        if (!found) {
            throw new RecordNotFoundException("Location with ID '" + locationIdToDelete + "' not found for deletion.");
        }

        // Overwrite the original file with the filtered rows
        try (ICSVWriter writer = createCsvWriter(false)) { // false = overwrite
            writer.writeAll(rowsToWrite);
        }
    }

    /**
     * Adds a new location record to the end of the CSV file.
     *
     * @param newLocationData An array representing the new location record.
     *                        Must match the expected CSV structure (ID, Name, City, Province, Category).
     * @throws IOException  If writing to the file fails.
     * @throws IllegalArgumentException If newLocationData is null or has incorrect length.
     */
    public void addRecord(String[] newLocationData) throws IOException {
        // Basic validation - adjust expected length if columns change
        int expectedColumns = 5;
        if (newLocationData == null || newLocationData.length < expectedColumns) {
            throw new IllegalArgumentException("New location data is invalid or incomplete. Expected " + expectedColumns + " columns.");
        }

        // Ensure header exists before appending
        writeHeaderIfNotPresent();

        try (ICSVWriter writer = createCsvWriter(true)) { // true = append
            writer.writeNext(newLocationData);
        }
    }


    /**
     * Finds the maximum numeric ID present in the ID column of the CSV file.
     * Assumes IDs are stored as strings but represent integers.
     *
     * @return An OptionalInt containing the maximum ID, or empty if the file is empty,
     *         has no valid IDs, or an error occurs.
     */
    public OptionalInt getMaxId() {
        int maxId = -1;
        boolean idFound = false;

        try (CSVReader reader = new CSVReaderBuilder(new FileReader(databaseFile))
                .withCSVParser(csvParser)
                .withSkipLines(1) // Skip header row for max ID calculation
                .build())
        {
            String[] nextLine;
            while ((nextLine = reader.readNext()) != null) {
                if (nextLine.length > ID_COLUMN && nextLine[ID_COLUMN] != null) {
                    try {
                        int id = Integer.parseInt(nextLine[ID_COLUMN].trim());
                        if (id > maxId) {
                            maxId = id;
                            idFound = true;
                        }
                    } catch (NumberFormatException e) {
                        System.err.println("Warning: Non-numeric ID encountered and skipped: " + nextLine[ID_COLUMN]);
                        // Continue processing other rows
                    }
                }
            }
        } catch (IOException | CsvException e) {
            System.err.println("Error reading file to determine max ID: " + e.getMessage());
            return OptionalInt.empty(); // Return empty on error
        }

        return idFound ? OptionalInt.of(maxId) : OptionalInt.empty();
    }


    /**
     * Reads all valid data rows from the CSV file (excluding the header).
     *
     * @return A List of String arrays, where each array represents a row.
     * @throws IOException if file reading fails.
     * @throws CsvException if CSV parsing fails.
     */
    public List<String[]> readAllRecords() throws IOException, CsvException {
        try (CSVReader reader = new CSVReaderBuilder(new FileReader(databaseFile))
                .withCSVParser(csvParser)
                .withSkipLines(1) // Skip header row
                .build())
        {
            return reader.readAll();
        }
    }


    // --- Main method for basic testing (Consider using JUnit for proper testing) ---
    public static void main(String[] args) {
        try {
            // 1. Get the file using FileManager (still okay for testing setup)
            File testDbFile = FileManager.getInstance().getDatabaseFile(); // Use a test-specific file
            System.out.println("Using test database: " + testDbFile.getAbsolutePath());

            // 2. Create an instance of DatabaseManager
            DatabaseManager dbManager = new DatabaseManager(testDbFile);

            // 3. Test adding data
            System.out.println("\n--- Testing Add ---");
            try {
                // Get next ID
                int nextIdNum = dbManager.getMaxId().orElse(-1) + 1;
                String nextId = String.format("%05d", nextIdNum);

                String[] location1 = {nextId, "Test Landmark " + nextId, "Test City", "Test Province", "Test Category"};
                dbManager.addRecord(location1);
                System.out.println("Added: " + String.join(",", location1));

                // Add another one
                nextIdNum++;
                nextId = String.format("%05d", nextIdNum);
                String[] location2 = {nextId, "Another Test", "Anytown", "BC", "Park"};
                dbManager.addRecord(location2);
                System.out.println("Added: " + String.join(",", location2));

            } catch (IOException e) {
                System.err.println("Error during add test: " + e.getMessage());
            }

            // 4. Test reading data
            System.out.println("\n--- Testing Read All ---");
            try {
                List<String[]> allData = dbManager.readAllRecords();
                System.out.println("Read " + allData.size() + " records:");
                for(String[] row : allData) {
                    System.out.println("  " + String.join(" | ", row));
                }
            } catch (IOException | CsvException e) {
                System.err.println("Error reading all records: " + e.getMessage());
            }


            // 5. Test Get Max ID
            System.out.println("\n--- Testing Max ID ---");
            OptionalInt maxIdOpt = dbManager.getMaxId();
            if (maxIdOpt.isPresent()) {
                System.out.println("Max ID found: " + maxIdOpt.getAsInt());
            } else {
                System.out.println("Max ID could not be determined (file empty or error).");
            }

            // 6. Test deleting data (use an ID known to exist from adding)
            System.out.println("\n--- Testing Delete ---");
            String idToDelete = String.format("%05d", dbManager.getMaxId().orElse(0)); // Get last added ID
            if (!idToDelete.equals("00000")){ // Check if there was an ID to delete
                try {
                    System.out.println("Attempting to delete record with ID: " + idToDelete);
                    dbManager.deleteById(idToDelete);
                    System.out.println("Deletion successful for ID: " + idToDelete);

                    // Verify deletion by reading again
                    List<String[]> dataAfterDelete = dbManager.readAllRecords();
                    System.out.println("Records after deletion: " + dataAfterDelete.size());
                    // Optional: Check if ID is truly gone

                } catch (RecordNotFoundException e) {
                    System.err.println("Delete failed: " + e.getMessage());
                } catch (IOException | CsvException e) {
                    System.err.println("Error during delete test: " + e.getMessage());
                }
            } else {
                System.out.println("Skipping delete test as no valid max ID found to delete.");
            }

            // Test deleting non-existent ID
            System.out.println("\n--- Testing Delete Non-Existent ---");
            try {
                String nonExistentId = "99999";
                System.out.println("Attempting to delete record with ID: " + nonExistentId);
                dbManager.deleteById(nonExistentId);
                System.out.println("!!! This should not be printed if exception handling works !!!");
            } catch (RecordNotFoundException e) {
                System.out.println("Correctly caught expected error: " + e.getMessage());
            } catch (IOException | CsvException e) {
                System.err.println("Unexpected error during non-existent delete test: " + e.getMessage());
            }


        } catch (IOException e) {
            System.err.println("Failed to initialize DatabaseManager for testing: " + e.getMessage());
            e.printStackTrace();
        } catch(IllegalArgumentException e) {
            System.err.println("Configuration error: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Custom exception for cases where a record lookup fails.
     */
    public static class RecordNotFoundException extends Exception {
        public RecordNotFoundException(String message) {
            super(message);
        }
    }
}
package TourCatData;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class FileManager {
    // Static instance of the singleton
    private static FileManager instance;

    // Resource directory path
    private Path resourceDirectory;

    private final boolean testMode;  // Made final so it cannot be changed after initialization

    // Private constructor with testMode parameter
    private FileManager(boolean testMode) {
        this.testMode = testMode;  // Assign testMode early

        // Set resource directory based on mode
        this.resourceDirectory = testMode
                ? Paths.get("src", "test", "resources")
                : Paths.get("src", "main", "resources");

        // Create the directory if it doesn't exist
        try {
            if (!Files.exists(resourceDirectory)) {
                Files.createDirectories(resourceDirectory);
            }
        } catch (IOException e) {
            System.err.println("Error creating resource directory: " + e.getMessage());
        }
    }

    // Method to get the singleton instance with specific mode
    public static synchronized FileManager getInstance(boolean testMode) {
        if (instance == null || instance.testMode != testMode) {
            instance = new FileManager(testMode);
        }
        return instance;
    }

    // For backward compatibility, default to production mode
    public static synchronized FileManager getInstance() {
        return getInstance(instance != null && instance.testMode);
    }

    // Get resource directory as Path object
    public Path getResourceDirectory() {
        return resourceDirectory;
    }

    // Get resource directory as File object
    public File getResourceDirectoryAsFile() {
        return resourceDirectory.toFile();
    }

    // Get resource directory as String
    public String getResourceDirectoryPath() {
        return resourceDirectory.toString();
    }

    // Get a specific resource file or directory within the resource directory
    public Path getResource(String resourceName) {
        return resourceDirectory.resolve(resourceName);
    }

    // Set custom resource directory
    public void setResourceDirectory(String directoryPath) {
        this.resourceDirectory = Paths.get(directoryPath);

        // Create the directory if it doesn't exist
        try {
            if (!Files.exists(resourceDirectory)) {
                Files.createDirectories(resourceDirectory);
            }
        } catch (IOException e) {
            System.err.println("Error creating resource directory: " + e.getMessage());
        }
    }

    public File getImageResourceFolder()
    {
        return getResourceFile("image");
    }

    // Check if a resource exists
    public boolean resourceExists(String resourceName) {
        return Files.exists(getResource(resourceName));
    }

    // Get current mode
    public boolean isTestMode() {
        return testMode;
    }

    public File getResourceFile(String fileName)
    {
        return new File(getResourceDirectoryPath() + File.separator + fileName);
    }

    public File getImageFile(String imageName)
    {
        return getResourceFile("image" + File.separator + imageName);
    }

    public File getDatabaseFile()
    {
        return getResourceFile("database.csv");
    }
}
package TourCatData;

public class LocationData {
    private final String id;
    private final String name;
    private final String city;
    private final String province;
    private final String category;
    // Maybe add image path later if needed, but ID is better

    public LocationData(String id, String name, String city, String province, String category) {
        this.id = id;
        this.name = name;
        this.city = city;
        this.province = province;
        this.category = category;
    }

    public String getId() { return id; }
    public String getName() { return name; }
    public String getCity() { return city; }
    public String getProvince() { return province; }
    public String getCategory() { return category; }

    // toString() for debugging can be useful
    @Override
    public String toString() {
        return "LocationData{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                ", city='" + city + '\'' +
                '}';
    }
}
package TourCatGUI;

import TourCatData.LocationData;
import TourCatService.LocationService;
import TourCatData.DatabaseManager;
import TourCatData.FileManager;

import javax.swing.*;
import java.awt.*;
import java.io.File;

public class AddForm extends JFrame {

    public JTextField nameField, cityField, provinceField, categoryField;
    public JButton submitButton, cancelButton, uploadImageButton;
    public JLabel submissionReplyLabel, imagePreviewLabel;
    private File imageDestination = null;
    private File selectedImage = null;

    LocationService locationService = null;

    public File saveFile;

    public AddForm(String username, LocationService locationService) {
        saveFile = FileManager.getInstance().getDatabaseFile();

        this.locationService = locationService;

        setTitle("Add Form");
        setSize(500, 500);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new GridBagLayout());

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1;
        gbc.anchor = GridBagConstraints.WEST;

        JLabel intro = new JLabel("Please enter the name and location of the landmark to be added");
        intro.setFont(new Font("Trebuchet MS", Font.BOLD, 15));

        nameField = new JTextField(20);
        cityField = new JTextField(20);
        provinceField = new JTextField(20);
        categoryField = new JTextField(20);
        submitButton = new JButton("Submit");
        cancelButton = new JButton("Cancel");
        uploadImageButton = new JButton("Choose Image");

        imagePreviewLabel = new JLabel();
        imagePreviewLabel.setPreferredSize(new Dimension(150, 120));
        imagePreviewLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK));

        submissionReplyLabel = new JLabel("");
        submissionReplyLabel.setFont(new Font("Trebuchet MS", Font.ITALIC, 12));

        // Row 0: Title
        gbc.gridx = 0; gbc.gridy = 0; gbc.gridwidth = 2;
        add(intro, gbc);

        // Row 1: Landmark Name Label & Field
        gbc.gridx = 0; gbc.gridy = 1; gbc.gridwidth = 1;
        add(new JLabel("Landmark name:"), gbc);
        gbc.gridx = 1;
        add(nameField, gbc);

        // Row 2: Landmark Location Label & Field
        gbc.gridx = 0; gbc.gridy = 2;
        add(new JLabel("Landmark city:"), gbc);
        gbc.gridx = 1;
        add(cityField, gbc);

        // Row 2: Landmark Location Label & Field
        gbc.gridx = 0; gbc.gridy = 3;
        add(new JLabel("Landmark province:"), gbc);
        gbc.gridx = 1;
        add(provinceField, gbc);

        // Row 2: Landmark Location Label & Field
        gbc.gridx = 0; gbc.gridy = 4;
        add(new JLabel("Landmark category:"), gbc);
        gbc.gridx = 1;
        add(categoryField, gbc);

        // Row 3: Image Label & Preview
        gbc.gridx = 0; gbc.gridy = 5;
        add(new JLabel("Selected Image:"), gbc);
        gbc.gridx = 1;
        add(imagePreviewLabel, gbc);

        // Row 4: Upload Image Button
        gbc.gridx = 1; gbc.gridy = 6;
        add(uploadImageButton, gbc);

        // Row 5: Submission Reply Label
        gbc.gridx = 0; gbc.gridy = 7; gbc.gridwidth = 2;
        add(submissionReplyLabel, gbc);

        // Row 6: Submit & Cancel Buttons
        gbc.gridx = 0; gbc.gridy = 8; gbc.gridwidth = 1;
        add(submitButton, gbc);
        gbc.gridx = 1;
        add(cancelButton, gbc);

        // Button Actions
        uploadImageButton.addActionListener(e -> selectImage());
        submitButton.addActionListener(e -> {
            submitForm();
        });
        cancelButton.addActionListener(e -> {
            new HomePage(username, locationService);
            dispose();
        });

        setVisible(true);
    }

    private void selectImage() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Choose an image");

        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            selectedImage = file;


            ImageIcon icon = new ImageIcon(new ImageIcon(selectedImage.getAbsolutePath())
                .getImage().getScaledInstance(150, 120, Image.SCALE_SMOOTH));
            imagePreviewLabel.setIcon(icon);
        }

        System.out.println("Selected Image:");
        System.out.println(selectedImage.getAbsolutePath());
    }

    private void addImageToResourceFolder(File image) {
        // Define the relative folder (inside src or another location)
        File destinationFolder = FileManager.getInstance().getResourceFile("image");
    }

    private void submitForm() {

        String name = nameField.getText();
        String location = cityField.getText();
        String province = provinceField.getText();
        String category = categoryField.getText();

        if (!isInputValid()){
            submissionReplyLabel.setText("Please enter the requested information of the landmark");
            return;
        }


        LocationData newLocationData = locationService.addLocation(name, location, province, category, this.selectedImage);

        if(selectedImage != null) addImageToResourceFolder(selectedImage);

        if (newLocationData == null) {
            submissionReplyLabel.setText("Failed to add location to the database");
            return;
        }

        submissionReplyLabel.setText("Location successfully added to the database");
        nameField.setText("");
        cityField.setText("");
        provinceField.setText("");
        categoryField.setText("");
        imagePreviewLabel.setIcon(null);
        selectedImage = null;
    }

    boolean isInputValid() {
        return !nameField.getText().isBlank() && !provinceField.getText().isBlank() && !categoryField.getText().isBlank();
    }
}
package TourCatGUI;

import TourCatData.LocationData;
import TourCatService.LocationService;
import TourCatSystem.LocationReader; // Keep for hideColumns helper

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumnModel;
import javax.swing.table.TableModel;
import javax.swing.table.TableRowSorter; // Import the sorter
import java.awt.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.ArrayList; // Needed for RowFilter list
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException; // For regex errors

// Import Levenshtein distance if you want true fuzzy filtering in RowFilter
import org.apache.commons.text.similarity.LevenshteinDistance;


public class CatalogView {

    //Ui componentes.
    private JFrame frame;
    private JTable table;
    private DefaultTableModel tableModel;
    private TableRowSorter<TableModel> sorter; // Add the sorter
    private JTextField searchField;
    private JButton viewButton;
    private JButton returnButton;
    private JButton deleteButton;
    private JButton filterButton; // Can likely remove this now
    private JButton resetButton;
    private JComboBox<String> provinceComboBox;
    private JComboBox<String> typeComboBox;

    // --- Service Layer ---
    private final LocationService locationService;

    // --- State ---
    // No longer need selectedProvince/Type state here if reading directly from combo boxes
    private final String username;

    // Levenshtein distance instance for fuzzy filter
    private static final LevenshteinDistance levenshteinDistance = new LevenshteinDistance(2); // Allow distance up to 2

    public CatalogView(String username, LocationService locationService) {
        if (locationService == null) {
            throw new IllegalArgumentException("LocationService cannot be null");
        }
        this.locationService = locationService;
        this.username = username;

        initComponents();
        layoutComponents();
        loadInitialData();

        frame.setLocationRelativeTo(null);
        frame.setVisible(true);
    }

    private void initComponents() {
        frame = new JFrame("TourCat Locations");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(800, 600);

        String[] columnNames = {"ID", "Name", "City", "Province", "Category"};
        tableModel = new DefaultTableModel(columnNames, 0);

        table = new JTable(tableModel);
        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

        // --- Setup TableRowSorter ---
        sorter = new TableRowSorter<>(tableModel);
        table.setRowSorter(sorter); // Attach sorter to the table

        hideTableColumns(new int[]{0});

        searchField = new JTextField();
        searchField.setToolTipText("Type to search (fuzzy match)...");
        setupSearchFieldPlaceholder(); // Use helper method

        // Key listener for live filtering using the sorter
        searchField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyReleased(KeyEvent e) {
                applyCombinedFilters(); // Apply filters on key release
            }
        });

        viewButton = new JButton("View Details");
        returnButton = new JButton("Return To Homepage");
        deleteButton = new JButton("Delete Selected");
        // filterButton = new JButton("Apply Filters"); // No longer needed if combo boxes filter live
        resetButton = new JButton("Reset Filters/Search");

        provinceComboBox = createProvinceComboBox();
        typeComboBox = createTypeComboBox();

        // Add Action Listeners (Listeners for ComboBoxes now trigger filtering)
        addActionListeners();
    }

    private void setupSearchFieldPlaceholder() {
        final String placeholder = "Search name, city, category...";
        searchField.setForeground(Color.GRAY);
        searchField.setText(placeholder);

        searchField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                if (searchField.getText().equals(placeholder)) {
                    searchField.setText("");
                    searchField.setForeground(Color.BLACK);
                }
            }
            @Override
            public void focusLost(FocusEvent e) {
                if (searchField.getText().isEmpty()) {
                    searchField.setForeground(Color.GRAY);
                    searchField.setText(placeholder);
                }
            }
        });
    }


    private void hideTableColumns(int[] columnsToHide) {
        TableColumnModel columnModel = table.getColumnModel();
        for (int colIndex : columnsToHide) {
            if (colIndex >= 0 && colIndex < columnModel.getColumnCount()) {
                // Using the existing static helper method from LocationReader
                LocationReader.hideColumns(columnModel, new int[]{colIndex});
            } else {
                System.err.println("Warning: Cannot hide column index " + colIndex + ". Index out of bounds.");
            }
        }
    }

    private JComboBox<String> createProvinceComboBox() {
        JComboBox<String> comboBox = new JComboBox<>();
        comboBox.addItem("All Provinces"); // Changed default text
        String[] provinces = {"Ontario", "Quebec", "British Columbia", "Alberta", "Manitoba", "Saskatchewan", "Nova Scotia", "New Brunswick", "Prince Edward Island", "Newfoundland and Labrador"};
        for (String p : provinces) {
            comboBox.addItem(p);
        }
        // Add listener to trigger filtering when selection changes
        comboBox.addActionListener(e -> applyCombinedFilters());
        return comboBox;
    }

    private JComboBox<String> createTypeComboBox() {
        JComboBox<String> comboBox = new JComboBox<>();
        comboBox.addItem("All Types"); // Changed default text
        String[] types = {"Park", "Waterfall", "Historic Site", "Landmark", "Bridge", "Lake"};
        for (String t : types) {
            comboBox.addItem(t);
        }
        // Add listener to trigger filtering when selection changes
        comboBox.addActionListener(e -> applyCombinedFilters());
        return comboBox;
    }

    private void addActionListeners() {
        viewButton.addActionListener(e -> viewSelectedLocation());
        deleteButton.addActionListener(e -> deleteSelectedLocation());
        // filterButton.addActionListener(e -> applyCombinedFilters()); // Not needed now
        resetButton.addActionListener(e -> resetView());

        returnButton.addActionListener(e -> {
            new HomePage(username, locationService).setVisible(true);
            frame.dispose();
        });
    }

    private void layoutComponents() {
        // --- Top Panel (Search + Filters) ---
        JPanel filterPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));
        filterPanel.add(new JLabel("Filter By:"));
        filterPanel.add(provinceComboBox);
        filterPanel.add(typeComboBox);
        // filterPanel.add(filterButton); // Removed button
        filterPanel.add(resetButton); // Moved Reset button here for better grouping

        JPanel topPanel = new JPanel(new BorderLayout(0, 5)); // Add vertical gap
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5)); // Add padding
        topPanel.add(searchField, BorderLayout.NORTH);
        topPanel.add(filterPanel, BorderLayout.CENTER); // Use Center for filters

        // --- Right Panel (Actions) ---
        JPanel rightPanel = new JPanel();
        rightPanel.setLayout(new BoxLayout(rightPanel, BoxLayout.Y_AXIS));
        rightPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        rightPanel.add(returnButton);
        rightPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        rightPanel.add(viewButton);
        rightPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        rightPanel.add(deleteButton);
        rightPanel.add(Box.createVerticalGlue());

        // --- Center Panel (Table) ---
        JScrollPane scrollPane = new JScrollPane(table);

        // --- Add Panels to Frame ---
        frame.setLayout(new BorderLayout(5, 5));
        frame.add(topPanel, BorderLayout.NORTH);
        frame.add(rightPanel, BorderLayout.EAST);
        frame.add(scrollPane, BorderLayout.CENTER);
    }

    private void loadInitialData() {
        try {
            // Clear existing filters before loading
            if (sorter != null) {
                sorter.setRowFilter(null);
            }
            List<LocationData> allLocations = locationService.getAllLocations();
            updateTableModel(allLocations); // This just updates the model data
            System.out.println("Initial data loaded. Rows in model: " + tableModel.getRowCount());
        } catch (Exception e) {
            System.err.println("Error loading initial location data: " + e.getMessage());
            e.printStackTrace();
            JOptionPane.showMessageDialog(frame,
                    "Could not load location data:\n" + e.getMessage(),
                    "Data Load Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    /**
     * Updates the table model data. The sorter will handle displaying it.
     */
    private void updateTableModel(List<LocationData> locations) {
        tableModel.setRowCount(0); // Clear existing rows in the model
        if (locations != null && !locations.isEmpty()) {
            for (LocationData loc : locations) {
                tableModel.addRow(new Object[]{
                        loc.getId(),
                        loc.getName() != null ? loc.getName() : "",
                        loc.getCity() != null ? loc.getCity() : "",
                        loc.getProvince() != null ? loc.getProvince() : "",
                        loc.getCategory() != null ? loc.getCategory() : ""
                });
            }
        }
        // The sorter will automatically update the view based on the new model data
        // and existing filter (if any).
    }

    /**
     * Applies filters based on the current state of search field and combo boxes.
     */
    private void applyCombinedFilters() {
        if (sorter == null) return; // Should not happen after init

        List<RowFilter<Object, Object>> filters = new ArrayList<>();

        // 1. Text Filter (Fuzzy or Regex)
        String searchText = searchField.getText();
        final String placeholder = "Search name, city, category...";
        if (searchText != null && !searchText.trim().isEmpty() && !searchText.equals(placeholder)) {
            // Option A: Simple Regex Filter (Case-Insensitive)
            // try {
            //     filters.add(RowFilter.regexFilter("(?i)" + Pattern.quote(searchText)));
            // } catch (PatternSyntaxException pse) {
            //     System.err.println("Bad regex pattern: " + pse.getMessage());
            // }
            // Option B: Custom Fuzzy RowFilter
            filters.add(createFuzzyRowFilter(searchText.toLowerCase()));
        }

        // 2. Province Filter
        String province = (String) provinceComboBox.getSelectedItem();
        if (province != null && !province.equals("All Provinces")) {
            // Column 3 is Province
            filters.add(RowFilter.regexFilter("^" + Pattern.quote(province) + "$", 3));
        }

        // 3. Type/Category Filter
        String type = (String) typeComboBox.getSelectedItem();
        if (type != null && !type.equals("All Types")) {
            // Column 4 is Category
            filters.add(RowFilter.regexFilter("^" + Pattern.quote(type) + "$", 4));
        }

        // Combine filters using AND logic
        RowFilter<Object, Object> combinedFilter = null;
        if (!filters.isEmpty()) {
            combinedFilter = RowFilter.andFilter(filters);
        }

        // Apply the combined filter to the sorter
        sorter.setRowFilter(combinedFilter);
    }

    /**
     * Creates a custom RowFilter implementing fuzzy matching.
     */
    private RowFilter<Object, Object> createFuzzyRowFilter(String query) {
        return new RowFilter<Object, Object>() {
            @Override
            public boolean include(Entry<?, ?> entry) {
                // Iterate through columns relevant for searching (skip ID column 0)
                for (int i = 1; i < entry.getValueCount(); i++) {
                    Object value = entry.getValue(i);
                    if (value != null) {
                        String cellText = value.toString().toLowerCase();
                        // Check if any word in the cell text is close enough
                        String[] words = cellText.split("\\s+"); // Split by whitespace
                        for (String word : words) {
                            if (levenshteinDistance.apply(query, word) <= 2) { // Using threshold 2
                                return true; // Match found in this row
                            }
                        }
                        // Optional: Check the whole cell text as well?
                        // if (levenshteinDistance.apply(query, cellText) <= 2) return true;
                    }
                }
                return false; // No match found in any relevant cell of this row
            }
        };
    }


    /**
     * Resets filters, search field, and clears the sorter's filter.
     */
    private void resetView() {
        provinceComboBox.setSelectedIndex(0); // "All Provinces"
        typeComboBox.setSelectedIndex(0);     // "All Types"
        setupSearchFieldPlaceholder(); // Reset search field text and color

        // Clear the sorter's filter to show all rows from the model
        if (sorter != null) {
            sorter.setRowFilter(null);
        }
        System.out.println("Filters and search reset. Showing all model data.");
        // Optional: Could reload data if needed, but usually not necessary if model is intact
        // loadInitialData();
    }


    // --- Action Methods ---

    private void viewSelectedLocation() {
        int selectedViewRow = table.getSelectedRow();
        if (selectedViewRow != -1) {
            int modelRow = table.convertRowIndexToModel(selectedViewRow);
            LocationData locationData = getLocationDataFromModelRow(modelRow);
            if (locationData != null) {
                DetailView detailView = new DetailView(this.frame, locationData);
                detailView.setVisible(true);
            } else {
                JOptionPane.showMessageDialog(frame, "Could not retrieve data for the selected row.", "Data Error", JOptionPane.WARNING_MESSAGE);
            }
        } else {
            JOptionPane.showMessageDialog(frame, "Please select a location from the table to view.", "No Selection", JOptionPane.INFORMATION_MESSAGE);
        }
    }

    private void deleteSelectedLocation() {
        int selectedViewRow = table.getSelectedRow();
        if (selectedViewRow != -1) {
            int modelRow = table.convertRowIndexToModel(selectedViewRow); // Use model row index!
            String locationId = (String) tableModel.getValueAt(modelRow, 0);
            String locationName = (String) tableModel.getValueAt(modelRow, 1);

            int confirmation = JOptionPane.showConfirmDialog(frame,"Are you sure you want to delete '" + locationName + "'?", "Confirm Deletion", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);

            if (confirmation == JOptionPane.YES_OPTION) {
                try {
                    locationService.deleteLocation(locationId);
                    // IMPORTANT: Remove the row from the MODEL, not the view directly.
                    // The sorter handles the view update.
                    tableModel.removeRow(modelRow);
                    // Re-apply filters in case the deletion affects the view, although
                    // removeRow should notify the sorter. It's usually safer though.
                    // applyCombinedFilters(); // Maybe not needed, test first.
                    JOptionPane.showMessageDialog(frame, "'" + locationName + "' deleted successfully.", "Deletion Successful", JOptionPane.INFORMATION_MESSAGE);
                } catch (Exception e) {
                    System.err.println("Error deleting location: " + e.getMessage());
                    e.printStackTrace();
                    JOptionPane.showMessageDialog(frame, "Could not delete location:\n" + e.getMessage(), "Deletion Error", JOptionPane.ERROR_MESSAGE);
                }
            }
        } else {
            JOptionPane.showMessageDialog(frame, "Please select a location from the table to delete.", "No Selection", JOptionPane.INFORMATION_MESSAGE);
        }
    }


    // --- Helper Methods ---

    private LocationData getLocationDataFromModelRow(int modelRowIndex) {
        if (modelRowIndex < 0 || modelRowIndex >= tableModel.getRowCount()) {
            System.err.println("Error: Attempted to access invalid model row index: " + modelRowIndex);
            return null;
        }
        try {
            String id = String.valueOf(tableModel.getValueAt(modelRowIndex, 0));
            String name = String.valueOf(tableModel.getValueAt(modelRowIndex, 1));
            String city = String.valueOf(tableModel.getValueAt(modelRowIndex, 2));
            String province = String.valueOf(tableModel.getValueAt(modelRowIndex, 3));
            String category = String.valueOf(tableModel.getValueAt(modelRowIndex, 4));
            return new LocationData(id, name, city, province, category);
        } catch (Exception e) {
            System.err.println("Unexpected error retrieving data from model row " + modelRowIndex + ": " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }
}
package TourCatGUI;

import TourCatData.LocationData; // Assuming DTO package
import TourCatData.FileManager;
import javax.swing.*;
import java.awt.*;
import java.io.File;

public class DetailView extends JDialog { // JDialog is often better for temporary detail views

    // Could inject FileManager, or use getInstance() for now
    private final FileManager fileManager = FileManager.getInstance();

    public DetailView(Frame owner, LocationData data) { // Pass parent frame for modality
        super(owner, "Location Details: " + data.getName(), true); // Modal dialog
        // Or: public LocationDetailView(LocationData data) { setTitle(...); } if using JFrame

        setSize(400, 400);
        setLayout(new BorderLayout());
        setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE); // Dispose only this dialog

        // --- Text Panel ---
        JPanel textPanel = new JPanel(new GridLayout(0, 1, 5, 5)); // Flexible rows, add gaps
        textPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); // Padding
        textPanel.add(createStyledLabel("Name: " + data.getName()));
        textPanel.add(createStyledLabel("City: " + data.getCity()));
        textPanel.add(createStyledLabel("Province: " + data.getProvince()));
        textPanel.add(createStyledLabel("Category: " + data.getCategory()));
        add(textPanel, BorderLayout.NORTH);

        // --- Image Panel ---
        JLabel imageLabel = new JLabel();
        imageLabel.setHorizontalAlignment(SwingConstants.CENTER);
        imageLabel.setPreferredSize(new Dimension(200, 200)); // Suggest size
        loadAndSetImage(imageLabel, data.getId());
        add(imageLabel, BorderLayout.CENTER);

        pack(); // Adjust size to fit components
        setLocationRelativeTo(owner); // Center relative to parent
    }

    // Helper for consistent label styling
    private JLabel createStyledLabel(String text) {
        JLabel label = new JLabel(text);
        label.setFont(new Font("Arial", Font.PLAIN, 14)); // Example style
        return label;
    }

    // Image loading logic extracted
    private void loadAndSetImage(JLabel imageLabel, String id) {
        // Construct potential paths
        File pngFile = fileManager.getImageFile(id + ".png");
        File jpgFile = fileManager.getImageFile(id + ".jpg");
        File imageFile = null;

        if (pngFile.exists()) {
            imageFile = pngFile;
        } else if (jpgFile.exists()) {
            imageFile = jpgFile;
        }

        System.out.println("Attempting to load image for ID " + id + ": " + (imageFile != null ? imageFile.getAbsolutePath() : "Not Found"));

        if (imageFile != null && imageFile.exists()) {
            try {
                ImageIcon icon = new ImageIcon(imageFile.getAbsolutePath());
                // Scale gracefully
                int width = 250; // Max width
                int height = 250; // Max height
                int imgWidth = icon.getIconWidth();
                int imgHeight = icon.getIconHeight();

                if (imgWidth > width || imgHeight > height) {
                    float scale = Math.min((float) width / imgWidth, (float) height / imgHeight);
                    int newWidth = (int) (imgWidth * scale);
                    int newHeight = (int) (imgHeight * scale);
                    Image scaledImage = icon.getImage().getScaledInstance(newWidth, newHeight, Image.SCALE_SMOOTH);
                    imageLabel.setIcon(new ImageIcon(scaledImage));
                } else {
                    imageLabel.setIcon(icon); // Use original if small enough
                }
                imageLabel.setText(null); // Clear any previous text
            } catch (Exception e) {
                System.err.println("Error loading image: " + imageFile.getAbsolutePath() + " - " + e.getMessage());
                imageLabel.setText("Error Loading Image");
                imageLabel.setIcon(null);
            }
        } else {
            imageLabel.setText("No Image Available");
            imageLabel.setIcon(null);
        }
    }
}
package TourCatGUI;

import TourCatData.DatabaseManager;
import TourCatService.LocationService;
import TourCatData.FileManager;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import java.net.Socket;
import java.awt.image.BufferedImage;
import java.io.File;
import javax.imageio.ImageIO;

public class HomePage extends JFrame {

   //Keep track of the user.
   private String loggedInUser;

   //Function Buttons.
   JButton homeButton = new JButton("Home");
   JButton loginButton = new JButton("Login");
   JButton catalogueButton = new JButton("Catalogue");
   JButton addButton = new JButton("Add to Catalogue");
   JButton logoutButton = new JButton("Logout");

   //Locaiton Service for altering locations in database and viewing.
   public LocationService locationService;

   //Set up the home page.

   public HomePage(String username, LocationService service) {
      super("TourCat");
      this.loggedInUser = username;
      this.locationService = service;

      this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

      Dimension initialSize = new Dimension(1000, 500);

      this.setSize(initialSize);
      this.setMinimumSize(initialSize);
      // NO Need to set layout on 'this' JFrame directly when using setContentPane

      // --- Background Panel Setup ---
      File skylineImg = FileManager.getInstance().getImageFile("torontoSkyline.jpg");
      BackgroundPanel bgPanel = new BackgroundPanel(skylineImg, 0.75f);
      // Set GridBagLayout on the panel that WILL BE the content pane
      bgPanel.setLayout(new GridBagLayout());
      setContentPane(bgPanel); // Make bgPanel the content pane

      // --- Welcome Label ---
      JLabel welcomeLabel = new JLabel(getWelcomeMessage(), SwingConstants.CENTER);
      welcomeLabel.setFont(new Font("Trebuchet MS", Font.BOLD, 36));
      welcomeLabel.setForeground(Color.WHITE);
      welcomeLabel.setOpaque(false);

      GridBagConstraints gbcWelcome = new GridBagConstraints(); // Use separate GBC for clarity
      gbcWelcome.gridx = 0;
      gbcWelcome.gridy = 1; // Place welcome label below top panel (gridy=1)
      gbcWelcome.weightx = 1.0;
      gbcWelcome.weighty = 1.0; // Let welcome label area take remaining vertical space
      gbcWelcome.anchor = GridBagConstraints.NORTHWEST; // Center it within its space
      gbcWelcome.insets = new Insets(40, 40, 40, 40);
      // Add welcomeLabel to bgPanel (the content pane)
      bgPanel.add(welcomeLabel, gbcWelcome);

      // --- Top Panel (Buttons & Search) ---
      homeButton = new JButton("Home");
      loginButton = new JButton("Login");
      catalogueButton = new JButton("Catalogue");
      addButton = new JButton("Add to Catalogue");
      logoutButton = new JButton("Logout");
      // ... configure buttons ...
      updateLoginLogoutUI();

      JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
      buttonPanel.setOpaque(false);
      buttonPanel.add(homeButton);
      buttonPanel.add(loginButton);
      buttonPanel.add(catalogueButton);
      buttonPanel.add(addButton);


      JTextField searchBar = new JTextField(15);
      JButton searchButton = new JButton("Search");
      JPanel searchPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
      searchPanel.setOpaque(false);
      searchPanel.add(searchBar);
      searchPanel.add(searchButton);

      // Create the topPanel itself
      JPanel topPanel = new JPanel(new BorderLayout());
      topPanel.setOpaque(false);
      topPanel.add(buttonPanel, BorderLayout.WEST);
      topPanel.add(searchPanel, BorderLayout.EAST);

      // --- FIX: Add topPanel to bgPanel using GridBagConstraints ---
      GridBagConstraints gbcTopPanel = new GridBagConstraints();
      gbcTopPanel.gridx = 0;      // First column
      gbcTopPanel.gridy = 0;      // First row (top)
      gbcTopPanel.weightx = 1.0;  // Take full width
      gbcTopPanel.weighty = 0;    // Don't take vertical space beyond preferred size
      gbcTopPanel.anchor = GridBagConstraints.NORTH; // Stick to the top
      gbcTopPanel.fill = GridBagConstraints.HORIZONTAL; // Ensure it fills horizontally
      gbcTopPanel.insets = new Insets(0, 0, 0, 0); // No padding needed usually

      // Add topPanel to bgPanel (the content pane) with these constraints
      bgPanel.add(topPanel, gbcTopPanel);

      // --- Action Listeners ---
      addHomePageActionListeners(welcomeLabel);

      // --- Finalize ---
      this.setLocationRelativeTo(null);
      this.setVisible(true);
   }

   // Helper method for adding action listeners
   private void addHomePageActionListeners(JLabel welcomeLabel) {
      loginButton.addActionListener(e -> {
         // this.setVisible(false); // Don't hide, dispose
         SwingUtilities.invokeLater(() -> {
            LoginGUI loginGUI = new LoginGUI();
            loginGUI.setVisible(true);
         });
         dispose(); // Close this HomePage window
         // No need to update welcomeLabel here, the window is closing
      });

      logoutButton.addActionListener(e -> performLogout(welcomeLabel)); // Call helper

      addButton.addActionListener(e -> {
         // this.setVisible(false); // Don't hide, dispose
         new AddForm(loggedInUser, locationService).setVisible(true);
         dispose();
      });

      catalogueButton.addActionListener(e -> {
         // this.setVisible(false); // Don't hide, dispose
         new CatalogView(loggedInUser, locationService); // CatalogView handles its visibility
         dispose();
      });

      homeButton.addActionListener(e -> {
         // Already home, do nothing or refresh if needed
         System.out.println("Home button clicked.");
      });
   }

   // Extracted logout logic (still needs SwingWorker ideally)
   private void performLogout(JLabel welcomeLabel) {
      if (loggedInUser == null) {
         JOptionPane.showMessageDialog(this, "No user is currently logged in.", "Error", JOptionPane.ERROR_MESSAGE);
         return;
      }

      // TODO: Wrap this network call in a SwingWorker!
      try (Socket socket = new Socket("localhost", 12345);
           PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);
           BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {

         System.out.println("Attempting to log out user: " + loggedInUser);
         writer.println("LOGOUT");
         writer.println(loggedInUser);

         String response = reader.readLine();
         if ("LOGOUT_SUCCESS".equals(response)) {
            JOptionPane.showMessageDialog(this, "Logout Successful!");
            loggedInUser = null; // Clear the logged-in user
         } else {
            JOptionPane.showMessageDialog(this, "Logout Failed: " + response, "Error", JOptionPane.ERROR_MESSAGE);
         }
      } catch (IOException ex) {
         JOptionPane.showMessageDialog(this, "Logout Error: Could not connect to server.", "Network Error", JOptionPane.ERROR_MESSAGE);
         ex.printStackTrace(); // Log for debugging
      } finally {
         // Update UI regardless of success/failure if user *attempted* logout
         updateLoginLogoutUI();
         welcomeLabel.setText(getWelcomeMessage());
      }
   }


   // Call this method after login/logout to update button visibility
   public void updateLoginLogoutUI() {
//      boolean isLoggedIn = (loggedInUser != null && !loggedInUser.isBlank());
//      loginButton.setVisible(!isLoggedIn);
//      logoutButton.setVisible(isLoggedIn);
//      // Only enable Add/Logout if logged in
//      addButton.setEnabled(isLoggedIn);
//      logoutButton.setEnabled(isLoggedIn); // Should only be visible if enabled anyway
//      // Decide if Catalogue is always enabled or requires login
//      // catalogueButton.setEnabled(isLoggedIn);
      homeButton.setEnabled(true);
      loginButton.setEnabled(loggedInUser == null);
      logoutButton.setEnabled(loggedInUser != null);
      addButton.setEnabled(true);
      catalogueButton.setEnabled(true);


   }

   private String getWelcomeMessage() {
      return (loggedInUser == null || loggedInUser.isBlank())
              ? "Welcome to TourCat!"
              : "Welcome to TourCat, " + loggedInUser + "!";
   }
}



class BackgroundPanel extends JPanel {
   private BufferedImage image;
   private float alpha; // Transparency level (0.0 - 1.0)

   public BackgroundPanel(File imageFile, float alpha) { // Constructor takes File
      this.alpha = Math.max(0.0f, Math.min(1.0f, alpha)); // Clamp alpha 0.0-1.0
      this.setOpaque(false); // Important for transparency to work well

      if (imageFile != null && imageFile.exists()) {
         try {
            System.out.println("Reading image: " + imageFile.getPath());
            image = ImageIO.read(imageFile);
            if (image == null) {
               System.err.println("ImageIO.read returned null for: " + imageFile.getPath());
            }
         } catch (IOException e) { // Catch specific IO exception
            System.err.println("Error reading background image: " + imageFile.getPath());
            e.printStackTrace();
            image = null; // Ensure image is null on error
         }
      } else {
         System.err.println("Background image file not found or is null: " + (imageFile != null ? imageFile.getPath() : "null"));
         image = null;
      }
   }

   @Override
   protected void paintComponent(Graphics g) {
      super.paintComponent(g); // Important for JPanel painting cycle
      if (image != null) {
         Graphics2D g2d = (Graphics2D) g.create(); // Create a copy for safe modification
         try {
            g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));
            // Draw image scaled to panel size
            g2d.drawImage(image, 0, 0, getWidth(), getHeight(), this);
         } finally {
            g2d.dispose(); // Dispose of the graphics copy
         }
      } else {
         // Optional: Draw a fallback background color if image failed to load
         g.setColor(Color.DARK_GRAY); // Example fallback
         g.fillRect(0, 0, getWidth(), getHeight());
         System.out.println("Drawing fallback background color.");
      }
   }

   public static void main(String[] args) {


      FileManager fileManager = FileManager.getInstance(true);
      DatabaseManager databaseManager = null;
      try {
         databaseManager = new DatabaseManager(fileManager.getDatabaseFile());
         LocationService service = new LocationService(databaseManager, fileManager);
         HomePage homePage = new HomePage("Username", service);
      } catch (IOException e) {
         throw new RuntimeException(e);
      }


   }
}
package TourCatGUI;

import TourCatData.DatabaseManager;
import TourCatData.FileManager;
import TourCatService.LocationService;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import java.net.Socket;

public class LoginGUI extends JFrame {
    public JTextField usernameField;
    private JPasswordField passwordField;
    private JButton loginButton;
    private JButton registerButton;
    //    private JButton logoutButton;
    private String loggedInUser = null; // Track the logged-in user
    private LocationService locationService;

    public LoginGUI() {

        FileManager fileManager = FileManager.getInstance(true);
        DatabaseManager databaseManager = null;
        try {
            databaseManager = new DatabaseManager(fileManager.getDatabaseFile());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        this.locationService = new LocationService(databaseManager, fileManager);
        // Set up the GUI
        setTitle("TourCat - Login");
        setSize(500, 250);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setBackground(Color.CYAN);



        setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));

        usernameField = new JTextField(15);
        passwordField = new JPasswordField(15);
        loginButton = new JButton("Login");
        registerButton = new JButton("Register");
//        logoutButton = new JButton("Logout");

        JLabel welcome = new JLabel("Welcome to TourCat! Please login to start touring :)");
        welcome.setFont(new Font("Trebuchet MS", Font.BOLD, 15));
        add(welcome);
        add(new JLabel("Username:"));
        add(usernameField);
        add(new JLabel("Password:"));
        add(passwordField);
        add(loginButton);
        add(registerButton);
//        add(logoutButton);

        // Disable logout button initially
//        logoutButton.setEnabled(false);

        // Add action listener for the login button
        loginButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                String username = usernameField.getText();
                String password = new String(passwordField.getPassword());

                try (Socket socket = new Socket("localhost", 12345);
                     PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);
                     BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {

                    // Send login request
                    writer.println("LOGIN");
                    writer.println(username);
                    writer.println(password);

                    // Receive response from the server
                    String response = reader.readLine();
                    if ("LOGIN_SUCCESS".equals(response)) {
                        loggedInUser = username; // Track the logged-in user
                        JOptionPane.showMessageDialog(LoginGUI.this, "Login Successful!");
                        loginButton.setEnabled(false);
                        registerButton.setEnabled(false);
                        loggedInUser = username;
                        SwingUtilities.invokeLater(() -> {
                            HomePage homePage = new HomePage(username, locationService);  // Open home screen
                            homePage.updateLoginLogoutUI(); // Update buttons on the homepage
                            dispose(); // Close login window
                        });


                    } else {
                        JOptionPane.showMessageDialog(LoginGUI.this, response, "Error", JOptionPane.ERROR_MESSAGE);
                    }
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        });

        // Add action listener for the register button
        registerButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                String username = usernameField.getText();
                String password = new String(passwordField.getPassword());

                try (Socket socket = new Socket("localhost", 12345);
                     PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);
                     BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {

                    // Send registration request
                    writer.println("REGISTER");
                    writer.println(username);
                    writer.println(password);

                    // Receive response from the server
                    String response = reader.readLine();
                    if ("REGISTRATION_SUCCESS".equals(response)) {
                        JOptionPane.showMessageDialog(LoginGUI.this, "Registration Successful!");

                        loggedInUser = username;
                        SwingUtilities.invokeLater(() -> {
                            HomePage homePage = new HomePage(username, locationService);  // Open home screen
                            homePage.updateLoginLogoutUI(); // Update buttons on the homepage
                            dispose(); // Close login window
                        });

                    } else {
                        JOptionPane.showMessageDialog(LoginGUI.this, response, "Error", JOptionPane.ERROR_MESSAGE);
                    }
                } catch (IOException ex) {
                    ex.printStackTrace();
                }
            }
        });

        // Add action listener for the logout button
//        logoutButton.addActionListener(new ActionListener() {
//            @Override
//            public void actionPerformed(ActionEvent e) {
//                if (loggedInUser == null) {
//                    JOptionPane.showMessageDialog(TourCatGUI.LoginGUI.this, "No user is currently logged in.", "Error", JOptionPane.ERROR_MESSAGE);
//                    return;
//                }
//
//                try (Socket socket = new Socket("localhost", 12345);
//                     PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);
//                     BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {
//
//                    // Debug: Print the username being sent
//                    System.out.println("Attempting to log out user: " + loggedInUser);
//
//                    // Send logout request
//                    writer.println("LOGOUT");
//                    writer.println(loggedInUser); // Send the logged-in username
//
//                    // Receive response from the server
//                    String response = reader.readLine();
//                    if ("LOGOUT_SUCCESS".equals(response)) {
//                        JOptionPane.showMessageDialog(TourCatGUI.LoginGUI.this, "Logout Successful!");
//                        loggedInUser = null; // Clear the logged-in user
//                        loginButton.setEnabled(true);
//                        registerButton.setEnabled(true);
//                        logoutButton.setEnabled(false);
//                    } else {
//                        JOptionPane.showMessageDialog(TourCatGUI.LoginGUI.this, response, "Error", JOptionPane.ERROR_MESSAGE);
//                    }
//                } catch (IOException ex) {
//                    ex.printStackTrace();
//                }
//            }
//        });
    }

    public static void main(String[] args) {


        FileManager fileManager = FileManager.getInstance(true);
        DatabaseManager databaseManager = null;
        try {
            databaseManager = new DatabaseManager(fileManager.getDatabaseFile());
            LocationService service = new LocationService(databaseManager, fileManager);
            HomePage homePage = new HomePage("Username", service);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
package TourCatGUI.Catalog;

import TourCatData.DatabaseManager;
import TourCatData.FileManager;
import TourCatGUI.HomePage;
import TourCatService.LocationService;
import TourCatSystem.Filter;
import TourCatSystem.LocationReader;
import com.opencsv.exceptions.CsvException;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumnModel;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

public class CataLogic {

    private CataView gui; // Reference to the GUI
    private String username;
    private File dataBaseFile;
    private DefaultTableModel tableModel;
    private FuzzyFinder fuzzyFinder;
    private Filter filter; // Reusable filter object

    private LocationService locationService;

    // Filter state
    private String selectedProvince = null;
    private String selectedType = null;

    public CataLogic(String username, LocationService locationService) {
        this.username = username;
        this.locationService = locationService;
        this.dataBaseFile = FileManager.getInstance().getDatabaseFile();
        this.filter = new Filter(); // Initialize filter with the database file

        // 1. Load initial data
        loadInitialTableData();

        // 2. Create the GUI, passing the model and this logic instance
        this.gui = new CataView(username, this, tableModel);

        // 3. Initialize components requiring GUI elements (like FuzzyFinder)
        this.fuzzyFinder = new FuzzyFinder(gui.getTable());

        // 4. Make the GUI visible
        this.gui.setVisible(true);
    }

    // --- Data Loading and Management ---

    private void loadInitialTableData() {
        LocationReader reader = new LocationReader(dataBaseFile);
        this.tableModel = reader.getTableModel();
        // Column hiding logic can stay here or move to GUI, let's keep it near the reader
        // We need a way to access the TableColumnModel *after* the GUI/JTable is created.
        // Let's add a method for the GUI to call *after* table creation.
    }

    // Called by GUI after JTable is created
    public void hideIdColumn(TableColumnModel columnModel) {
        LocationReader.hideColumns(columnModel, new int[]{0}); // Assuming column 0 is ID
    }

    private void updateTableModel(ArrayList<String> results) {
        // Clear existing data (important!)
        tableModel.setRowCount(0);

        // Get column names (assuming they don't change)
        // String[] columnNames = ... ; // If needed, but DefaultTableModel handles this

        if (results != null) {
            for (String resultLine : results) {
                if (resultLine != null && !resultLine.trim().isEmpty()) {
                    String[] rowData = resultLine.split(","); // Assuming CSV
                    // Basic validation: Ensure enough columns exist
                    if (rowData.length >= tableModel.getColumnCount()) {
                        // If ID is hidden but present in data, adjust indices or ensure model matches data structure
                        tableModel.addRow(rowData);
                    } else {
                        System.err.println("Skipping malformed row: " + resultLine);
                        // Optionally, pad with empty strings if necessary:
                        // Object[] paddedRow = new Object[tableModel.getColumnCount()];
                        // System.arraycopy(rowData, 0, paddedRow, 0, rowData.length);
                        // java.util.Arrays.fill(paddedRow, rowData.length, paddedRow.length, "");
                        // tableModel.addRow(paddedRow);
                    }
                }
            }
        }
        // No need to call fireTableDataChanged if using addRow/setRowCount on DefaultTableModel
    }


    private ArrayList<String> readAllDataFromFile() {
        ArrayList<String> allResults = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new FileReader(dataBaseFile))) {
            String line;
            boolean isFirstLine = true; // Assuming header row
            while ((line = br.readLine()) != null) {
                if (isFirstLine) {
                    isFirstLine = false;
                    continue; // Skip the header line
                }
                if (!line.trim().isEmpty()) { // Avoid adding blank lines
                    allResults.add(line);
                }
            }
        } catch (IOException ex) {
            gui.showError("Error reading database file: " + ex.getMessage());
            ex.printStackTrace(); // Log for debugging
        }
        return allResults;
    }


    // --- Action Handlers (Called by GUI listeners) ---

    public void handleSearch(String searchText) {
        // Avoid searching on the placeholder text
        if (searchText != null && !searchText.equals("Search here:")) {
            fuzzyFinder.performFuzzySearch(searchText);
        } else {
            // Optional: If search text is empty or placeholder, reset to show all (or filtered) results
            handleFilterAction(); // Re-apply filters or show all if no filters active
        }
    }

    public void handleReturnAction() {

        new HomePage(username, locationService); // Assuming HomePage exists and works
        gui.dispose();
    }

    public void handleViewAction() {
        int selectedRow = gui.getSelectedRow();
        if (selectedRow != -1) {
            // Convert view index to model index in case of sorting/filtering
            int modelRow = gui.getTable().convertRowIndexToModel(selectedRow);

            // Get data using model index
            String id = (String) tableModel.getValueAt(modelRow, 0); // Assumes ID is column 0
            String name = (String) tableModel.getValueAt(modelRow, 1);
            String city = (String) tableModel.getValueAt(modelRow, 2);
            String province = (String) tableModel.getValueAt(modelRow, 3);
            String category = (String) tableModel.getValueAt(modelRow, 4);

            // Find the corresponding image file
            File imageFile = FileManager.getInstance().getImageFile(id + ".png");
            if (!imageFile.exists()) {
                imageFile = FileManager.getInstance().getImageFile(id + ".jpg");
            }
            // If neither exists, imageFile will point to the non-existent .jpg path

            // Ask GUI to display the details window
            gui.displayDetailsWindow(id, name, city, province, category, imageFile);

        } else {
            gui.showMessage("Please select a location from the table to view details.");
        }
    }

    public void handleDeleteAction() {
        int selectedRow = gui.getSelectedRow();
        if (selectedRow != -1) {
            // Show confirmation dialog
            int confirmation = JOptionPane.showConfirmDialog(
                    gui.frame, // Parent component
                    "Are you sure you want to delete this location?\n" + tableModel.getValueAt(gui.getTable().convertRowIndexToModel(selectedRow), 1), // Message showing name
                    "Confirm Deletion", // Title
                    JOptionPane.YES_NO_OPTION, // Options
                    JOptionPane.WARNING_MESSAGE // Icon
            );

            if (confirmation == JOptionPane.YES_OPTION) {
                int modelRow = gui.getTable().convertRowIndexToModel(selectedRow);
                String selectedRowID = (String) tableModel.getValueAt(modelRow, 0);


                DatabaseManager databaseManager = null;
                try {
                    databaseManager = new DatabaseManager(dataBaseFile);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }

                boolean success = false;
                try {
                    databaseManager.deleteById(selectedRowID);
                } catch (IOException | DatabaseManager.RecordNotFoundException | CsvException e) {
                    throw new RuntimeException(e);
                }

                if (success) {
                    // Remove row from the model (this will update the JTable)
                    tableModel.removeRow(modelRow);
                    gui.showMessage("Location deleted successfully.");
                } else {
                    gui.showError("Failed to delete the location from the database file.");
                }
            }
        } else {
            gui.showMessage("Please select a location from the table to delete.");
        }
    }

    public void handleFilterAction() {
        filter.reset(); // Clear previous filter results within the Filter object

        boolean provinceSelected = selectedProvince != null && !selectedProvince.isEmpty();
        boolean typeSelected = selectedType != null && !selectedType.isEmpty();

        if (provinceSelected && typeSelected) {
            filter.filterBoth(selectedProvince, selectedType);
        } else if (provinceSelected) {
            filter.filterProvince(selectedProvince);
        } else if (typeSelected) {
            filter.filterType(selectedType);
        } else {
            // No filters selected, show all data
            ArrayList<String> allData = readAllDataFromFile();
            updateTableModel(allData);
            // Optionally show a message if you *require* a filter to be selected
            // gui.showMessage("Please select at least one filter option or reset filters.");
            return; // Exit after showing all data
        }

        // Get results from the filter and update the table model
        ArrayList<String> results = filter.getResults();
        updateTableModel(results);

        if(results.isEmpty()){
            gui.showMessage("No locations match the selected filters.");
        }
    }

    public void handleResetAction() {
        // 1. Clear filter state in logic
        selectedProvince = null;
        selectedType = null;

        // 2. Tell GUI to reset combo boxes and potentially search field
        gui.resetFilters();

        // 3. Reload all data from the file
        ArrayList<String> allResults = readAllDataFromFile();

        // 4. Update the table model
        updateTableModel(allResults);

        // 5. Clear any active JTable sorting/filtering (if FuzzyFinder or JTable itself adds it)
        gui.getTable().setRowSorter(null); // Remove sorter temporarily
        fuzzyFinder = new FuzzyFinder(gui.getTable()); // Recreate FuzzyFinder with the fresh table state

        gui.showMessage("Filters reset. Showing all locations.");
    }


    // --- State Update Methods (Called by GUI listeners) ---

    public void updateSelectedProvince(String province) {
        this.selectedProvince = province; // Store null if "Select Province" was chosen
    }

    public void updateSelectedType(String type) {
        this.selectedType = type; // Store null if "Select Type" was chosen
    }
}
package TourCatGUI.Catalog;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.io.File;

public class CataView {

    private CataLogic logic; // Reference to the logic class
    private String username;

    // --- GUI Components ---
    JFrame frame;
    JTable table;
    DefaultTableModel tableModel; // Model managed by logic, but GUI needs reference
    JTextField searchField;
    JButton viewButton;
    JButton returnButton;
    JButton deleteButton;
    JButton filterButton;
    JButton resetButton;
    JComboBox<String> provinceComboBox;
    JComboBox<String> typeComboBox;
    JScrollPane scrollPane;
    JPanel rightPanel;
    JPanel filterPanel;
    JPanel topPanel;
    JLabel filterBy;

    // Constructor takes username, logic instance, and the table model
    CataView(String username, CataLogic logic, DefaultTableModel tableModel) {
        this.username = username;
        this.logic = logic;
        this.tableModel = tableModel; // Use the model created by logic

        initComponents();
        layoutComponents();
        attachListeners();

        // Initial setup
        searchField.setText("Search here:"); // Initial placeholder
        logic.hideIdColumn(table.getColumnModel()); // Ask logic to hide column
    }

    // --- Initialization Helper ---
    private void initComponents() {
        frame = new JFrame("Tour Catalog - " + username);
        table = new JTable(tableModel); // Use the provided model
        scrollPane = new JScrollPane(table);
        searchField = new JTextField();
        viewButton = new JButton("View Details");
        returnButton = new JButton("Return To Homepage");
        deleteButton = new JButton("Delete Location");
        filterButton = new JButton("Apply Filters");
        resetButton = new JButton("Reset Filters");
        rightPanel = new JPanel();
        filterPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 0));
        topPanel = new JPanel(new BorderLayout());
        filterBy = new JLabel("Filter By:");

        // Province ComboBox Setup
        provinceComboBox = new JComboBox<>();
        provinceComboBox.addItem("Select Province");
        provinceComboBox.addItem("Ontario");
        provinceComboBox.addItem("Quebec");
        provinceComboBox.addItem("British Columbia");
        provinceComboBox.addItem("Alberta");
        provinceComboBox.addItem("Manitoba");
        provinceComboBox.addItem("Saskatchewan");
        provinceComboBox.addItem("Nova Scotia");
        provinceComboBox.addItem("New Brunswick");
        provinceComboBox.addItem("Prince Edward Island");
        provinceComboBox.addItem("Newfoundland and Labrador");
        // Add more provinces as needed

        // Type ComboBox Setup
        typeComboBox = new JComboBox<>();
        typeComboBox.addItem("Select Type");
        typeComboBox.addItem("Park");
        typeComboBox.addItem("Waterfall");
        typeComboBox.addItem("Historic Site");
        typeComboBox.addItem("Landmark");
        // Add more types as needed
    }

    // --- Layout Helper ---
    private void layoutComponents() {
        // Frame setup
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(800, 600);
        frame.setLayout(new BorderLayout());

        // Right Panel (Buttons)
        rightPanel.setLayout(new GridLayout(5, 1, 5, 10)); // Added gaps
        rightPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); // Padding
        rightPanel.add(returnButton);
        rightPanel.add(viewButton);
        rightPanel.add(deleteButton);
        // Add some spacing if needed, or adjust GridLayout

        // Filter Panel
        filterPanel.add(filterBy);
        filterPanel.add(provinceComboBox);
        filterPanel.add(typeComboBox);
        filterPanel.add(filterButton);
        filterPanel.add(resetButton);
        filterPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5)); // Padding

        // Top Panel (Search + Filters)
        topPanel.add(searchField, BorderLayout.NORTH);
        topPanel.add(filterPanel, BorderLayout.CENTER); // Changed to CENTER for better fit

        // Add components to frame
        frame.add(topPanel, BorderLayout.NORTH);
        frame.add(scrollPane, BorderLayout.CENTER);
        frame.add(rightPanel, BorderLayout.EAST);

        frame.setLocationRelativeTo(null); // Center on screen
    }

    // --- Listener Setup Helper ---
    private void attachListeners() {
        // Search field placeholder text behavior
        searchField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                if (searchField.getText().equals("Search here:")) {
                    searchField.setText("");
                    searchField.setForeground(Color.BLACK); // Reset text color
                }
            }

            @Override
            public void focusLost(FocusEvent e) {
                if (searchField.getText().isEmpty()) {
                    searchField.setText("Search here:");
                    searchField.setForeground(Color.GRAY); // Set placeholder color
                }
            }
        });
        searchField.setForeground(Color.GRAY); // Initial placeholder color

        // Search key listener - delegates to logic
        searchField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyReleased(KeyEvent e) {
                logic.handleSearch(searchField.getText());
            }
        });

        // Button listeners - delegate to logic
        viewButton.addActionListener(e -> logic.handleViewAction());
        returnButton.addActionListener(e -> logic.handleReturnAction());
        deleteButton.addActionListener(e -> logic.handleDeleteAction());
        filterButton.addActionListener(e -> logic.handleFilterAction());
        resetButton.addActionListener(e -> logic.handleResetAction());

        // ComboBox listeners - update logic's state
        provinceComboBox.addActionListener(e -> {
            String selection = (String) provinceComboBox.getSelectedItem();
            logic.updateSelectedProvince(selection.equals("Select Province") ? null : selection);
        });

        typeComboBox.addActionListener(e -> {
            String selection = (String) typeComboBox.getSelectedItem();
            logic.updateSelectedType(selection.equals("Select Type") ? null : selection);
        });
    }

    // --- Methods called by Logic to update GUI ---

    public void setVisible(boolean visible) {
        frame.setVisible(visible);
    }

    public void dispose() {
        frame.dispose();
    }

    public int getSelectedRow() {
        return table.getSelectedRow();
    }

    public Object getValueAt(int row, int col) {
        // Ensure row/col are valid before accessing model directly
        if (row >= 0 && row < tableModel.getRowCount() && col >= 0 && col < tableModel.getColumnCount()) {
            return tableModel.getValueAt(row, col);
        }
        return null; // Or throw an exception
    }

    // Method to remove a row visually - Model is updated by logic
    public void removeTableRow(int viewRow) {
        // Important: Convert view row index to model row index if sorting/filtering is enabled
        // For now, assuming a direct mapping if no complex sorting/filtering is active on the JTable itself
        int modelRow = table.convertRowIndexToModel(viewRow);
        // The logic class should ideally handle model changes.
        // This might be redundant if logic already removed from the model it passed.
        // Let's assume logic handles the model, and we just need to know it changed.
        // tableModel.fireTableRowsDeleted(modelRow, modelRow); // Or let logic fire this
    }


    public String getSearchText() {
        String text = searchField.getText();
        return text.equals("Search here:") ? "" : text; // Return empty if placeholder
    }

    public void setSearchText(String text) {
        searchField.setText(text);
        if (text.isEmpty() || text.equals("Search here:")) {
            searchField.setText("Search here:");
            searchField.setForeground(Color.GRAY);
        } else {
            searchField.setForeground(Color.BLACK);
        }
    }

    public JTable getTable() {
        return table; // Needed by FuzzyFinder potentially
    }

    public void resetFilters() {
        provinceComboBox.setSelectedIndex(0);
        typeComboBox.setSelectedIndex(0);
        // Resetting search text might also be desired here
        // setSearchText(""); // Uncomment if you want to clear search on filter reset
    }

    public void showMessage(String message) {
        JOptionPane.showMessageDialog(frame, message, "Information", JOptionPane.INFORMATION_MESSAGE);
    }

    public void showError(String message) {
        JOptionPane.showMessageDialog(frame, message, "Error", JOptionPane.ERROR_MESSAGE);
    }

    // --- Details Popup ---
    public void displayDetailsWindow(String id, String name, String city, String province, String category, File imageFile) {
        JFrame detailsFrame = new JFrame("Location Details: " + name);
        detailsFrame.setSize(450, 450); // Adjusted size
        detailsFrame.setLayout(new BorderLayout(10, 10)); // Added gaps
        detailsFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); // Dispose only this window

        // Panel for text details
        JPanel textPanel = new JPanel();
        textPanel.setLayout(new GridLayout(0, 1, 5, 5)); // Flexible rows, add gaps
        textPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); // Padding
        textPanel.add(new JLabel("<html><b>Name:</b> " + name + "</html>"));
        textPanel.add(new JLabel("<html><b>City:</b> " + city + "</html>"));
        textPanel.add(new JLabel("<html><b>Province:</b> " + province + "</html>"));
        textPanel.add(new JLabel("<html><b>Category:</b> " + category + "</html>"));
        textPanel.add(new JLabel("<html><b>ID:</b> " + id + "</html>")); // Show ID

        // Image Label
        JLabel imageLabel = new JLabel();
        imageLabel.setHorizontalAlignment(SwingConstants.CENTER);
        imageLabel.setVerticalAlignment(SwingConstants.CENTER);
        imageLabel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        if (imageFile != null && imageFile.exists()) {
            try {
                ImageIcon icon = new ImageIcon(imageFile.getAbsolutePath());
                // Scale image proportionally to fit within bounds (e.g., 300x300)
                int maxWidth = 300;
                int maxHeight = 300;
                int imgWidth = icon.getIconWidth();
                int imgHeight = icon.getIconHeight();

                if (imgWidth > maxWidth || imgHeight > maxHeight) {
                    double scale = Math.min((double) maxWidth / imgWidth, (double) maxHeight / imgHeight);
                    int scaledWidth = (int) (imgWidth * scale);
                    int scaledHeight = (int) (imgHeight * scale);
                    Image scaledImage = icon.getImage().getScaledInstance(scaledWidth, scaledHeight, Image.SCALE_SMOOTH);
                    imageLabel.setIcon(new ImageIcon(scaledImage));
                } else {
                    imageLabel.setIcon(icon); // Use original size if small enough
                }
                imageLabel.setText(null); // Clear text if image is loaded

            } catch (Exception e) {
                System.err.println("Error loading image: " + imageFile.getAbsolutePath() + " - " + e.getMessage());
                imageLabel.setText("Error loading image");
                imageLabel.setIcon(null);
            }
        } else {
            imageLabel.setText("No Image Available");
            imageLabel.setIcon(null);
        }

        // Add components to frame
        detailsFrame.add(textPanel, BorderLayout.NORTH);
        detailsFrame.add(imageLabel, BorderLayout.CENTER);

        detailsFrame.setLocationRelativeTo(frame); // Center relative to main window
        detailsFrame.setVisible(true);
    }
}
package TourCatGUI.Catalog;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableRowSorter;
import java.awt.*;
import java.util.List;
import java.util.regex.PatternSyntaxException;

public class FuzzyFinder { // Renaming might be good later if not using fuzzy logic

    private final JTable table;
    private final TableRowSorter<DefaultTableModel> sorter;
    // Define which columns are searchable (using their MODEL indices)
    // Example: Assuming 0=ID, 1=Name, 2=City, 3=Province, 4=Category
    private final List<Integer> searchableColumns = List.of(1, 2, 3, 4); // Exclude ID column (index 0)

    /**
     * Creates a finder/filterer for the given JTable.
     * It sets up a TableRowSorter to enable dynamic filtering.
     *
     * @param table The JTable to apply filtering to.
     */
    public FuzzyFinder(JTable table) {
        this.table = table;
        if (!(table.getModel() instanceof DefaultTableModel)) {
            throw new IllegalArgumentException("FuzzyFinder requires a DefaultTableModel for the JTable.");
        }
        DefaultTableModel model = (DefaultTableModel) table.getModel();
        this.sorter = new TableRowSorter<>(model);
        this.table.setRowSorter(sorter);
    }

    /**
     * Applies a filter to the table based on the query string.
     * Rows are included if the query (case-insensitive) is found as a substring
     * in any of the searchable columns.
     *
     * @param query The text to search for. If empty or null, the filter is cleared.
     */
    public void performFuzzySearch(String query) {
        final String preparedQuery = (query == null) ? "" : query.trim().toLowerCase();

        if (preparedQuery.isEmpty()) {
            // If query is empty, remove the filter to show all rows
            sorter.setRowFilter(null);
        } else {
            try {
                // Create a RowFilter that checks designated columns for the query substring
                RowFilter<DefaultTableModel, Integer> rowFilter = new RowFilter<>() {
                    @Override
                    public boolean include(Entry<? extends DefaultTableModel, ? extends Integer> entry) {
                        // Iterate only through the searchable columns defined earlier
                        for (int colIndex : searchableColumns) {
                            // Ensure the column index is valid for the current row entry
                            if (colIndex >= 0 && colIndex < entry.getValueCount()) {
                                Object value = entry.getValue(colIndex);
                                if (value != null) {
                                    // Convert cell value to lowercase string and check for substring
                                    String cellText = value.toString().toLowerCase();
                                    if (cellText.contains(preparedQuery)) {
                                        return true; // Match found in this row, include it
                                    }
                                }
                            }
                        }
                        // No match found in any searchable column for this row
                        return false;
                    }
                };
                // Apply the filter
                sorter.setRowFilter(rowFilter);

            } catch (PatternSyntaxException e) {
                // This catch block might be relevant if using regex-based filters in the future.
                // For simple contains, it's less likely to be hit unless the query itself causes issues
                // (highly unlikely for basic strings).
                System.err.println("Error applying filter: " + e.getMessage());
                sorter.setRowFilter(null); // Clear filter on error
            }
        }
    }

    // --- Optional: Alternative using Regex for more complex patterns ---
    // (Uncomment and use this instead of the contains-based filter if needed)
    /*
    public void performRegexSearch(String query) {
        final String preparedQuery = (query == null) ? "" : query.trim();

        if (preparedQuery.isEmpty()) {
            sorter.setRowFilter(null);
        } else {
            try {
                // Create a case-insensitive regex pattern
                // We escape the query to treat it literally unless you intend regex features
                Pattern pattern = Pattern.compile(Pattern.quote(preparedQuery), Pattern.CASE_INSENSITIVE);

                RowFilter<DefaultTableModel, Integer> rowFilter = new RowFilter<>() {
                    @Override
                    public boolean include(Entry<? extends DefaultTableModel, ? extends Integer> entry) {
                        for (int colIndex : searchableColumns) {
                            if (colIndex >= 0 && colIndex < entry.getValueCount()) {
                                Object value = entry.getValue(colIndex);
                                if (value != null) {
                                    Matcher matcher = pattern.matcher(value.toString());
                                    if (matcher.find()) { // Check if the pattern is found anywhere
                                        return true;
                                    }
                                }
                            }
                        }
                        return false;
                    }
                };
                sorter.setRowFilter(rowFilter);
            } catch (PatternSyntaxException e) {
                System.err.println("Invalid regex pattern: " + e.getMessage());
                sorter.setRowFilter(null); // Clear filter on error
            }
        }
    }
    */

    /**
     * Clears any active filter, showing all rows.
     */
    public void clearFilter() {
        sorter.setRowFilter(null);
    }


    // Example main method for basic testing (requires a visible JFrame)
    public static void main(String[] args) {
        // --- Setup Minimal GUI for Testing ---
        JFrame frame = new JFrame("FuzzyFinder Test");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(600, 400);
        frame.setLayout(new BorderLayout());

        // Sample Data
        String[] columnNames = {"ID", "Name", "City", "Type"};
        Object[][] data = {
                {"1", "Niagara Falls", "Niagara", "Waterfall"},
                {"2", "CN Tower", "Toronto", "Landmark"},
                {"3", "Stanley Park", "Vancouver", "Park"},
                {"4", "Parliament Hill", "Ottawa", "Historic Site"},
                {"5", "Old Quebec", "Quebec City", "Historic Site"},
                {"6", "Lake Louise", "Banff", "Lake"},
                {"7", "Signal Hill", "St. John's", "Historic Site"}
        };

        DefaultTableModel model = new DefaultTableModel(data, columnNames);
        JTable table = new JTable(model);
        JScrollPane scrollPane = new JScrollPane(table);

        // Create the Finder instance AFTER table and model are set up
        FuzzyFinder finder = new FuzzyFinder(table);
        // IMPORTANT: Make sure finder's searchableColumns match your sample data indices
        // finder.searchableColumns = List.of(1, 2, 3); // Adjust if needed

        JTextField searchField = new JTextField();
        searchField.addActionListener(e -> finder.performFuzzySearch(searchField.getText())); // Filter on Enter
        searchField.putClientProperty("JTextField.placeholderText", "Type to search and press Enter...");


        JButton clearButton = new JButton("Clear Filter");
        clearButton.addActionListener(e -> {
            searchField.setText("");
            finder.clearFilter();
        });

        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.add(new JLabel("Search:"), BorderLayout.WEST);
        topPanel.add(searchField, BorderLayout.CENTER);
        topPanel.add(clearButton, BorderLayout.EAST);


        frame.add(topPanel, BorderLayout.NORTH);
        frame.add(scrollPane, BorderLayout.CENTER);

        frame.setLocationRelativeTo(null);
        frame.setVisible(true);
        // --- End GUI Setup ---


        // You can also test programmatically (though less visual)
        System.out.println("Testing programmatically:");
        finder.performFuzzySearch("Park");
        System.out.println("Rows visible after searching 'Park': " + table.getRowCount()); // Shows filtered row count

        try { Thread.sleep(2000); } catch (InterruptedException e) {} // Pause

        finder.performFuzzySearch("hiStoric");
        System.out.println("Rows visible after searching 'hiStoric': " + table.getRowCount());

        try { Thread.sleep(2000); } catch (InterruptedException e) {} // Pause

        finder.clearFilter();
        System.out.println("Rows visible after clearing filter: " + table.getRowCount());
    }
}
package TourCatGUI.Forms;

import javax.swing.*;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.awt.*;
import java.io.File;

public class AddFormGUI extends JFrame {

    // Reference to the logic class
    private final AddFormLogic logic;
    private final String username; // Keep username if needed for cancel action

    // --- GUI Components ---
    JTextField nameField, cityField, provinceField, categoryField;
    JButton submitButton, cancelButton, uploadImageButton;
    JLabel submissionReplyLabel, imagePreviewLabel, introLabel;

    // Constructor takes username and logic instance
    public AddFormGUI(String username, AddFormLogic logic) {
        this.username = username;
        this.logic = logic;

        initComponents();
        layoutComponents();
        attachListeners();

        // Frame setup
        setTitle("Add New Location");
        setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); // Dispose instead of Exit
        setLocationRelativeTo(null); // Center on screen
        pack(); // Adjusts size to fit components
    }

    // --- Initialization Helper ---
    private void initComponents() {
        introLabel = new JLabel("Enter details for the new location:");
        introLabel.setFont(new Font("Trebuchet MS", Font.BOLD, 15));

        nameField = new JTextField(25);
        cityField = new JTextField(25);
        provinceField = new JTextField(25);
        categoryField = new JTextField(25);

        submitButton = new JButton("Submit Location");
        cancelButton = new JButton("Cancel");
        uploadImageButton = new JButton("Choose Image...");

        imagePreviewLabel = new JLabel();
        imagePreviewLabel.setPreferredSize(new Dimension(150, 120));
        imagePreviewLabel.setHorizontalAlignment(SwingConstants.CENTER);
        imagePreviewLabel.setVerticalAlignment(SwingConstants.CENTER);
        imagePreviewLabel.setBorder(BorderFactory.createEtchedBorder()); // Use EtchedBorder
        imagePreviewLabel.setText("No Image Selected");

        submissionReplyLabel = new JLabel(" "); // Start with a space for layout stability
        submissionReplyLabel.setFont(new Font("Trebuchet MS", Font.ITALIC, 12));
        submissionReplyLabel.setForeground(Color.GRAY); // Default color
    }

    // --- Layout Helper ---
    private void layoutComponents() {
        setLayout(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(8, 8, 8, 8); // Increased insets for spacing
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        // Row 0: Title
        gbc.gridx = 0; gbc.gridy = 0; gbc.gridwidth = 2;
        gbc.weightx = 1.0; // Allow title to expand horizontally
        add(introLabel, gbc);
        gbc.weightx = 0; // Reset weightx for labels
        gbc.gridwidth = 1; // Reset gridwidth

        // Row 1: Landmark Name Label & Field
        gbc.gridx = 0; gbc.gridy = 1;
        add(new JLabel("Name:"), gbc);
        gbc.gridx = 1; gbc.weightx = 1.0; // Allow field to expand
        add(nameField, gbc);
        gbc.weightx = 0; // Reset

        // Row 2: City Label & Field
        gbc.gridx = 0; gbc.gridy = 2;
        add(new JLabel("City:"), gbc);
        gbc.gridx = 1; gbc.weightx = 1.0;
        add(cityField, gbc);
        gbc.weightx = 0;

        // Row 3: Province Label & Field
        gbc.gridx = 0; gbc.gridy = 3;
        add(new JLabel("Province:"), gbc);
        gbc.gridx = 1; gbc.weightx = 1.0;
        add(provinceField, gbc);
        gbc.weightx = 0;

        // Row 4: Category Label & Field
        gbc.gridx = 0; gbc.gridy = 4;
        add(new JLabel("Category:"), gbc);
        gbc.gridx = 1; gbc.weightx = 1.0;
        add(categoryField, gbc);
        gbc.weightx = 0;

        // Row 5: Image Preview
        gbc.gridx = 0; gbc.gridy = 5;
        add(new JLabel("Image Preview:"), gbc);
        gbc.gridx = 1; gbc.weightx = 1.0; // Let preview take space
        gbc.fill = GridBagConstraints.NONE; // Don't stretch image label itself
        gbc.anchor = GridBagConstraints.CENTER; // Center preview
        add(imagePreviewLabel, gbc);
        gbc.fill = GridBagConstraints.HORIZONTAL; // Reset fill
        gbc.anchor = GridBagConstraints.WEST; // Reset anchor
        gbc.weightx = 0; // Reset weight

        // Row 6: Upload Image Button
        gbc.gridx = 1; gbc.gridy = 6;
        gbc.fill = GridBagConstraints.NONE; // Don't stretch button
        gbc.anchor = GridBagConstraints.LINE_START; // Align button left within its cell
        add(uploadImageButton, gbc);
        gbc.fill = GridBagConstraints.HORIZONTAL; // Reset fill
        gbc.anchor = GridBagConstraints.WEST; // Reset anchor

        // Row 7: Submission Reply Label
        gbc.gridx = 0; gbc.gridy = 7; gbc.gridwidth = 2;
        gbc.weightx = 1.0;
        add(submissionReplyLabel, gbc);
        gbc.weightx = 0;
        gbc.gridwidth = 1;

        // Row 8: Buttons (using a sub-panel for better alignment)
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 10, 0)); // Align right
        buttonPanel.add(cancelButton);
        buttonPanel.add(submitButton);
        gbc.gridx = 0; gbc.gridy = 8; gbc.gridwidth = 2;
        gbc.anchor = GridBagConstraints.EAST; // Align panel right
        add(buttonPanel, gbc);
    }

    // --- Listener Setup Helper ---
    private void attachListeners() {
        // Delegate actions to the logic class
        submitButton.addActionListener(e -> logic.handleSubmitAction());
        cancelButton.addActionListener(e -> logic.handleCancelAction());
        uploadImageButton.addActionListener(e -> logic.handleUploadImageAction());
    }

    // --- Methods Called by Logic to Update GUI ---

    /**
     * Displays a file chooser for image selection.
     * @return The selected File, or null if none was selected.
     */
    public File showImageFileChooser() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Choose an image");
        // Filter for common image types
        FileNameExtensionFilter filter = new FileNameExtensionFilter(
                "Images (JPG, PNG, GIF)", "jpg", "jpeg", "png", "gif");
        fileChooser.setFileFilter(filter);
        fileChooser.setAcceptAllFileFilterUsed(false); // Only allow specified image types

        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            return fileChooser.getSelectedFile();
        }
        return null; // User cancelled or closed dialog
    }

    /**
     * Sets the image preview label.
     * @param icon The ImageIcon to display (should be appropriately scaled), or null to clear.
     */
    public void setImagePreview(ImageIcon icon) {
        imagePreviewLabel.setIcon(icon);
        if (icon == null) {
            imagePreviewLabel.setText("No Image Selected");
        } else {
            imagePreviewLabel.setText(null); // Remove text when image is present
        }
    }

    /**
     * Updates the submission status label.
     * @param message The message to display.
     * @param isError True if the message represents an error (sets text color to red), false otherwise (green for success, gray for info).
     */
    public void setSubmissionReply(String message, boolean isError) {
        submissionReplyLabel.setText(message);
        if (isError) {
            submissionReplyLabel.setForeground(Color.RED);
        } else if (message.toLowerCase().contains("success")) {
            submissionReplyLabel.setForeground(new Color(0, 128, 0)); // Dark Green
        } else {
            submissionReplyLabel.setForeground(Color.GRAY); // Default informational
        }
    }

    /** Clears all input fields and the image preview. */
    public void clearForm() {
        nameField.setText("");
        cityField.setText("");
        provinceField.setText("");
        categoryField.setText("");
        setImagePreview(null); // Clear image preview
        setSubmissionReply(" ", false); // Reset reply label
    }

    // --- Getters for Logic ---
    public String getNameText() { return nameField.getText(); }
    public String getCityText() { return cityField.getText(); }
    public String getProvinceText() { return provinceField.getText(); }
    public String getCategoryText() { return categoryField.getText(); }

}
package TourCatGUI.Forms;

import TourCatData.DatabaseManager;
import TourCatData.FileManager;
import TourCatData.LocationData;
import TourCatGUI.HomePage;
import TourCatService.LocationService;
import org.apache.commons.io.FilenameUtils; // Ensure this dependency is present

import javax.swing.*;
import java.awt.*;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;

public class AddFormLogic {

    private final AddFormGUI gui; // Reference to the GUI
    private final String username;
    private final LocationService locationService;
    private File selectedImage = null; // Holds the currently selected image file

    private DatabaseManager databaseManager;

    public AddFormLogic(String username, LocationService locationService) {
        this.username = username;
        this.locationService = locationService;

        // Create the GUI, passing this logic instance
        this.gui = new AddFormGUI(username, this);

        // Make the GUI visible
        this.gui.setVisible(true);
    }

    // --- Action Handlers (Called by GUI listeners) ---

    /** Handles the action when the 'Choose Image' button is clicked. */
    public void handleUploadImageAction() {
        File file = gui.showImageFileChooser();
        if (file != null) {
            this.selectedImage = file;
            try {
                // Create a scaled ImageIcon for the preview
                ImageIcon originalIcon = new ImageIcon(selectedImage.getAbsolutePath());
                Image scaledImage = originalIcon.getImage().getScaledInstance(
                        150, 120, Image.SCALE_SMOOTH);
                ImageIcon previewIcon = new ImageIcon(scaledImage);
                gui.setImagePreview(previewIcon);
                gui.setSubmissionReply("Image selected: " + file.getName(), false);
            } catch (Exception e) {
                // Handle potential errors loading the image
                System.err.println("Error creating image preview: " + e.getMessage());
                gui.setImagePreview(null); // Clear preview on error
                gui.setSubmissionReply("Error loading image preview.", true);
                this.selectedImage = null; // Invalidate selected image if preview failed
            }
        } else {
            // User cancelled selection, optionally clear preview if needed
            // gui.setImagePreview(null);
            // this.selectedImage = null;
            gui.setSubmissionReply("Image selection cancelled.", false);
        }
    }

    /** Handles the action when the 'Submit' button is clicked. */
    public void handleSubmitAction() {
        // 1. Get data from GUI
        String name = gui.getNameText().trim();
        String city = gui.getCityText().trim();
        String province = gui.getProvinceText().trim();
        String category = gui.getCategoryText().trim();

        // 2. Validate input
        if (!isInputValid(name, city, province, category)) {
            gui.setSubmissionReply("Validation Error: Please fill in Name, Province, and Category.", true);
            return;
        }

        // 3. Prepare data for storage
        String nextIdStr = generateNextId();
        String[] newLocationData = new String[5];
        newLocationData[0] = (nextIdStr);
        newLocationData[1] = (name);
        newLocationData[2] = (city); // Add city even if blank, handle in DB/display if needed
        newLocationData[3] = (province);
        newLocationData[4] = (category);


        LocationData locationData = locationService.addLocation(name, city, province, category, selectedImage);




//        // 6. Final success handling (if data and image saved)
//        if (imageSaveSuccess) {
//            gui.setSubmissionReply("Success: Location added to the database!", false);
//            gui.clearForm(); // Clear the form on full success
//            this.selectedImage = null; // Reset selected image state
//        }
    }

    /** Handles the action when the 'Cancel' button is clicked. */
    public void handleCancelAction() {
        // Assuming HomePage takes username and shows itself
        new HomePage(username, locationService);
        gui.dispose(); // Close the AddForm window
    }


    // --- Helper Methods ---

    /**
     * Generates the next sequential ID based on the current max ID in the database.
     * @return The formatted ID string (e.g., "00015").
     */
    private String generateNextId() {
        int maxId = this.databaseManager.getMaxId().getAsInt();
        int nextId = maxId + 1;
        return String.format("%05d", nextId); // Formats with leading zeros up to 5 digits
    }

    /**
     * Validates the core required input fields.
     * Basic check: Name, Province, Category must not be blank.
     * @param name Name input
     * @param city City input (optional in this validation)
     * @param province Province input
     * @param category Category input
     * @return true if the essential input is valid, false otherwise.
     */
    public boolean isInputValid(String name, String city, String province, String category) {
        // City is often optional, main requirement here is Name, Province, Category
        return name != null && !name.isBlank() &&
                province != null && !province.isBlank() &&
                category != null && !category.isBlank();
    }
    // Main method for testing this specific form (optional)
    // Usually, the application starts from a central point (like MainApplication)
    public static void main(String[] args) {

        FileManager fileManager = FileManager.getInstance(true);
        try {
            DatabaseManager databaseManager = new DatabaseManager(fileManager.getDatabaseFile());

            LocationService service = new LocationService(databaseManager, fileManager);

            // Run the GUI on the Event Dispatch Thread
            SwingUtilities.invokeLater(() -> new AddFormLogic("TestUser", service));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }


    }
}
package TourCatServer;

import java.io.*;
import java.net.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

public class LoginServer {
    private static final int PORT = 12345;
    private static final String CREDENTIALS_FILE = "credentials.txt";
    private static HashMap<String, String> credentials = new HashMap<>();
    private static Set<String> loggedInUsers = new HashSet<>(); // Track logged-in users

    public static void main(String[] args) {
        // Load credentials from file at startup
        loadCredentialsFromFile();

        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            System.out.println("Server is listening on port " + PORT);

            while (true) {
                Socket socket = serverSocket.accept();
                System.out.println("New client connected");

                // Handle client in a separate thread
                new ClientHandler(socket).start();
            }
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    // Load credentials from file
    private static void loadCredentialsFromFile() {
        try (BufferedReader br = new BufferedReader(new FileReader(CREDENTIALS_FILE))) {
            String line;
            while ((line = br.readLine()) != null) {
                String[] parts = line.split(":");
                if (parts.length == 2) {
                    credentials.put(parts[0], parts[1]);
                }
            }
            System.out.println("Credentials loaded from file.");
        } catch (IOException e) {
            System.out.println("No credentials file found. Starting with an empty database.");
        }
    }

    // Save credentials to file
    private static void saveCredentialsToFile() {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(CREDENTIALS_FILE))) {
            for (String username : credentials.keySet()) {
                bw.write(username + ":" + credentials.get(username));
                bw.newLine();
            }
            System.out.println("Credentials saved to file.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static class ClientHandler extends Thread {
        private Socket socket;
        private String username; // Track the username for this client

        public ClientHandler(Socket socket) {
            this.socket = socket;
        }

        public void run() {
            try (InputStream input = socket.getInputStream();
                 BufferedReader reader = new BufferedReader(new InputStreamReader(input));
                 OutputStream output = socket.getOutputStream();
                 PrintWriter writer = new PrintWriter(output, true)) {

                // Read the request type (LOGIN, REGISTER, or LOGOUT)
                String requestType = reader.readLine();

                if ("LOGIN".equals(requestType)) {
                    // Handle login request
                    handleLogin(reader, writer);
                } else if ("REGISTER".equals(requestType)) {
                    // Handle registration request
                    handleRegistration(reader, writer);
                } else if ("LOGOUT".equals(requestType)) {
                    // Handle logout request
                    handleLogout(reader,writer);
                } else {
                    writer.println("INVALID_REQUEST");
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            } finally {
                if (username != null && loggedInUsers.contains(username)) {
                    System.out.println("Client disconnected: " + username);
                }
            }
        }

        private void handleLogin(BufferedReader reader, PrintWriter writer) throws IOException {
            // Read username and password from client
            username = reader.readLine();
            String password = reader.readLine();

            // Authenticate
            if (credentials.containsKey(username) && credentials.get(username).equals(password)) {
                if (!loggedInUsers.contains(username)) {
                    loggedInUsers.add(username); // Mark user as logged in
                    writer.println("LOGIN_SUCCESS");
                    System.out.println("User logged in: " + username);
                } else {
                    writer.println("LOGIN_FAILED: User already logged in");
                }
            } else {
                writer.println("LOGIN_FAILED: Invalid credentials");
            }
        }

        private void handleRegistration(BufferedReader reader, PrintWriter writer) throws IOException {
            // Read username and password from client
            String newUsername = reader.readLine();
            String newPassword = reader.readLine();

            // Check if username already exists
            if (credentials.containsKey(newUsername)) {
                writer.println("REGISTRATION_FAILED: Username already exists");
            } else {
                // Add new user to credentials
                credentials.put(newUsername, newPassword);
                saveCredentialsToFile(); // Save updated credentials to file
                writer.println("REGISTRATION_SUCCESS");
                System.out.println("New user registered: " + newUsername);
            }
        }

        private void handleLogout(BufferedReader reader, PrintWriter writer) throws IOException {
            String usernameToLogout = reader.readLine(); // Read username from client

            System.out.println("Received logout request for user: " + usernameToLogout);
            System.out.println("Logged-in users before logout: " + loggedInUsers);

            if (usernameToLogout != null && loggedInUsers.contains(usernameToLogout)) {
                loggedInUsers.remove(usernameToLogout);
                writer.println("LOGOUT_SUCCESS");
                System.out.println("User logged out: " + usernameToLogout);
            } else {
                writer.println("LOGOUT_FAILED: User not logged in");
            }
        }

    }
}
package TourCatService;

import TourCatData.DatabaseManager;
import TourCatData.FileManager;
import TourCatData.LocationData;
import TourCatSystem.LocationReader;
import com.opencsv.exceptions.CsvException;
import org.apache.commons.io.FilenameUtils;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class LocationService {

    private final DatabaseManager databaseManager;
    private final FileManager fileManager;

    public LocationService(DatabaseManager databaseManager, FileManager fileManager)
    {
        this.databaseManager = databaseManager;
        this.fileManager = fileManager;
    }



    /**
     * Adds a new location and optionally saves its associated image.
     * @param name Name of the location.
     * @param city City of the location.
     * @param province Province of the location.
     * @param category Category of the location.
     * @return The newly created LocationData object with its assigned ID.
     */
    public LocationData addLocation(String name, String city, String province, String category, File imageFile) {

        // 2. Generate a robust ID (UUID is better than sequential)
        // String id = String.format("%05d", databaseManager.getMaxId(fileManager.getDatabaseFile()) + 1); // Fragile
        String id = UUID.randomUUID().toString(); // More robust

        // 3. Create the Data Transfer Object
        LocationData newLocation = new LocationData(id, name, city, province, category);

        // 4. Prepare data for persistence (Convert DTO to format needed by current DatabaseManager)
        ArrayList<String> dataRow = new ArrayList<>();
        dataRow.add(newLocation.getId());
        dataRow.add(newLocation.getName());
        dataRow.add(newLocation.getCity());
        dataRow.add(newLocation.getProvince());
        dataRow.add(newLocation.getCategory());

        // 5. Persist the location data (using the injected dependency)
        File dbFile = fileManager.getDatabaseFile();


        try {
            databaseManager.addRecord(dataRow.toArray(String[]::new)); // Use static method for now
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        if (imageFile != null) {
            try {
                saveImageForLocation(newLocation.getId(), imageFile);
            } catch (IOException e) {
                System.err.println("Location data saved, but failed to save image: " + e.getMessage());
            }
        }

        return newLocation; // Return the created object
    }

    /**
     * Retrieves all locations.
     * @return A list of all LocationData objects.
     */
    public List<LocationData> getAllLocations(){
        // This needs improvement - DatabaseManager doesn't provide this directly.
        // The LocationReader logic should be moved to a DAO or within this service/DAO layer.
        // For now, simulate by using LocationReader temporarily (BAD PRACTICE)

        File dbFile = fileManager.getDatabaseFile();

        System.out.println("Reading CSV file from: "+  dbFile.getAbsolutePath());

        // This logic belongs in a DAO:
        LocationReader reader = new LocationReader(dbFile); // Re-reading file every time! Inefficient.
        javax.swing.table.DefaultTableModel model = reader.getTableModel();
        List<LocationData> locations = new ArrayList<>();
        for (int i = 0; i < model.getRowCount(); i++) {
            locations.add(new LocationData(
                    (String) model.getValueAt(i, 0), // ID
                    (String) model.getValueAt(i, 1), // Name
                    (String) model.getValueAt(i, 2), // City
                    (String) model.getValueAt(i, 3), // Province
                    (String) model.getValueAt(i, 4)  // Category
            ));
        }
        System.out.println(locations.get(0));
        System.out.println("Found " + locations.size() + " locations in the LocationService Database!");
        return locations;
    }

    /**
     * Deletes a location by its ID.
     * @param locationId The ID of the location to delete.
     */
    public void deleteLocation(String locationId)  {
        File dbFile = fileManager.getDatabaseFile();
        // DatabaseManager deletes by name currently - this needs to be changed to ID!
        // For now, we'd need to first find the name by ID (inefficient) or modify DatabaseManager.
        // Assuming DatabaseManager.deleteFromFile is modified to take ID (index 0):

        try {
            databaseManager.deleteById(locationId);
        } catch (IOException | DatabaseManager.RecordNotFoundException | CsvException e) {
            throw new RuntimeException(e);
        }


        // Attempt to delete associated images (png/jpg)
        try {
            deleteImagesForLocation(locationId);
        } catch (IOException e) {
            System.err.println("Warning: Location data deleted, but failed to delete associated image(s) for ID " + locationId + ": " + e.getMessage());
            // Don't throw exception here, primary data is gone. Just log.
        }
    }

    /**
     * Finds locations based on search criteria. (Simplified version)
     * This should ideally query the DAO layer.
     * @param query Search term (searches name, city, etc.)
     * @param province Filter by province (null or empty to ignore)
     * @param category Filter by category (null or empty to ignore)
     * @return A list of matching LocationData objects.
     */
    public List<LocationData> findLocations(String query, String province, String category) {
        // This is highly inefficient with CSV. A real DAO/database is needed.
        // Re-implementing search/filter logic here based on getAllLocations:
        List<LocationData> allLocations = getAllLocations();
        List<LocationData> filteredLocations = new ArrayList<>();

        for (LocationData loc : allLocations) {
            boolean match = true;

            // Filter by province
            if (province != null && !province.isBlank() && !province.equalsIgnoreCase(loc.getProvince())) {
                match = false;
            }
            // Filter by category
            if (match && category != null && !category.isBlank() && !category.equalsIgnoreCase(loc.getCategory())) {
                match = false;
            }
            // Filter by query (simple contains check across fields)
            if (match && query != null && !query.isBlank()) {
                String lowerQuery = query.toLowerCase();
                if (!(loc.getName().toLowerCase().contains(lowerQuery) ||
                        (loc.getCity() != null && loc.getCity().toLowerCase().contains(lowerQuery)) || // Handle potential null city
                        loc.getProvince().toLowerCase().contains(lowerQuery) ||
                        loc.getCategory().toLowerCase().contains(lowerQuery))) {
                    match = false;
                }
            }

            if (match) {
                filteredLocations.add(loc);
            }
        }
        return filteredLocations;
    }

    /**
     * Retrieves a single location by its ID.
     * @param locationId The ID of the location.
     * @return The LocationData object.
     */
    public LocationData getLocationById(String locationId) {
        // Inefficient: Iterate through all locations to find by ID
        List<LocationData> allLocations = getAllLocations();
        for (LocationData loc : allLocations) {
            if (loc.getId().equals(locationId)) {
                return loc;
            }
        }

        return null;
    }


    // --- Helper methods for image handling ---

    private void saveImageForLocation(String locationId, File sourceImageFile) throws IOException {
        File destinationFolder = fileManager.getResourceFile("image"); // Use FileManager
        if (!destinationFolder.exists()) {
            destinationFolder.mkdirs(); // Ensure image directory exists
        }

        String extension = FilenameUtils.getExtension(sourceImageFile.getName());
        if (extension == null || extension.isEmpty()) {
            extension = "jpg"; // Default extension if none found
            System.err.println("Warning: Image file has no extension, assuming ." + extension);
        }

        // Use location ID as base filename
        String destinationFilename = locationId + "." + extension;
        File destinationFile = new File(destinationFolder, destinationFilename);

        // Copy the file
        Files.copy(sourceImageFile.toPath(), destinationFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
        System.out.println("Image saved to: " + destinationFile.getAbsolutePath());
    }

    private void deleteImagesForLocation(String locationId) throws IOException {
        File imageFolder = fileManager.getResourceFile("image");
        if (!imageFolder.exists() || !imageFolder.isDirectory()) {
            return; // No image folder, nothing to delete
        }

        // Attempt to delete common image types for this ID
        String[] extensions = {"png", "jpg", "jpeg", "gif"};
        boolean deleted = false;
        for (String ext : extensions) {
            File imageFile = new File(imageFolder, locationId + "." + ext);
            if (imageFile.exists()) {
                if (Files.deleteIfExists(imageFile.toPath())) {
                    System.out.println("Deleted image: " + imageFile.getName());
                    deleted = true;
                } else {
                    System.err.println("Failed to delete image: " + imageFile.getName());
                }
            }
        }
        //if (!deleted) { System.out.println("No image files found to delete for ID: " + locationId); }
    }
}
package TourCatSystem;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class DatabaseFileReader {

    private final File databaseFile;

    public DatabaseFileReader(File databaseFile) {
        if (databaseFile == null || !databaseFile.exists() || !databaseFile.isFile()) {
            throw new IllegalArgumentException("Invalid database file provided: " +
                    (databaseFile == null ? "null" : databaseFile.getAbsolutePath()));
        }
        this.databaseFile = databaseFile;
    }

    /**
     * Reads all data lines (excluding the header) from the database file.
     *
     * @return A List of strings, each representing a data row from the file.  Returns an empty list on error.
     */
    public List<String> readAllDataLines() {
        List<String> lines = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new FileReader(databaseFile))) {
            String line;
            boolean isFirstLine = true;
            while ((line = br.readLine()) != null) {
                if (isFirstLine) {
                    isFirstLine = false;  // Skip header
                    continue;
                }
                if (!line.trim().isEmpty()) {
                    lines.add(line);
                }
            }
        } catch (IOException e) {
            System.err.println("Error reading database file: " + e.getMessage());
            // Consider throwing a custom exception here
        }
        return lines;
    }
}
package TourCatSystem;

import TourCatData.FileManager;

import java.io.File;
import java.util.ArrayList;

public class Filter {
    private ArrayList<String> results;
    private ArrayList<String> provinces;
    private ArrayList<String> types;

    static String province;
    static String type;

    private static final File database = FileManager.getInstance().getDatabaseFile();

    public Filter(){
        provinces = new ArrayList<>();
        types = new ArrayList<>();
        results = new ArrayList<>();

        types.add("Park");
        types.add("Historic Site");
        types.add("Bridge");
        types.add("Waterfall");


        provinces.add("Ontario");
        provinces.add("Quebec");
        provinces.add("British Columbia");
        provinces.add("Alberta");
        provinces.add("Manitoba");
        provinces.add("Saskatchewan");
        provinces.add("Nova Scotia");
        provinces.add("New Brunswick");
        provinces.add("Prince Edward Island");
        provinces.add("Newfoundland and Labrador");

    }

    // User clicks 1 chosen province

    public void filterProvince(String selectedProvince) {
        Search searchObj = new Search();
        province = selectedProvince; // Dropdown input
        results.clear();
        results = searchObj.search(database, province);
    }


    // User clicks 1 chosen type

    public void filterType(String selectedType) {
        Search searchObj = new Search();
        type = selectedType; // Dropdown input
        results.clear();
        results = searchObj.search(database, type);
    }

    // User clicks 1 chosen province AND 1 chosen type

    public void filterBoth(String selectedProvince, String selectedType) {
        Search searchObj = new Search();
        province = selectedProvince; // Dropdown input
        type = selectedType; // Dropdown input
        results.clear();

        ArrayList<String> firstResults = searchObj.search(database, province);

        for(String line : firstResults){
            if(line.toLowerCase().contains(type.toLowerCase())){
                results.add(line);
            }
        }
    }
    public ArrayList<String> getResults() {
        return results;
    }

    public void printResults() {
        if (results.isEmpty()) {
            System.out.println("No matching results found.");
        } else {
            for (String result : results) {
                System.out.println(result);
            }
        }
    }

    public void reset()
    {
        results.clear();
    }


    public static void main(String[] args) {
        Filter filter = new Filter();

        // Search by province
        filter.filterProvince("Ontario");
        System.out.println("\nShowing results for province: " + province);
        filter.printResults();

        // Search by type
        filter.filterType("Lake");
        System.out.println("\nShowing results for type: " + type);
        filter.printResults();

        // Search by both province and type
        filter.filterBoth("Ontario", "Water");
        System.out.println("\nShowing results for both province and type: " + province + " ," + type);
        filter.printResults();
    }
}

package TourCatSystem;

public class Landmark {
    int ID;
    String GeographicalName;
    String LandmarkName;
    String City;
    PROVINCE Province;
    String Category;

    public enum PROVINCE {
        ONTARIO,
        QUEBEC,
        BRITISH_COLUMBIA,
        ALBERTA,
        MANITOBA,
        SASKATCHEWAN,
        NOVA_SCOTIA,
        NEW_BRUNSWICK,
        PRINCE_EDWARD_ISLAND,
        NEWFOUNDLAND_AND_LABRADOR,
        NORTHWEST_TERRITORIES,
        YUKON,
        NUNAVUT
    }

    public enum CATEGORYTYPE{
    }

    Landmark(int ID, String GeoName, String LandmarkName, String city, PROVINCE PROVINCE, String category)
    {
        this.ID = ID;
        this.GeographicalName = GeoName;
        this.LandmarkName = LandmarkName;
        this.City = city;
        this.Province = PROVINCE;
        this.Category = category;
    }




}

package TourCatSystem;

import com.opencsv.CSVReader;
import com.opencsv.exceptions.CsvValidationException;

import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumnModel;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

//The location reader class will be the class responsible for reading from
//the csv file.
public class LocationReader {

    private DefaultTableModel tableModel;

    public LocationReader(File file)
    {

        try(CSVReader reader = new CSVReader(new FileReader(file))){

            String[] header = reader.readNext();

            tableModel = new DefaultTableModel();

            if (header != null)
            {
                tableModel.setColumnIdentifiers(header);
            }

            String[] line;
            while((line = reader.readNext()) != null)
            {
                tableModel.addRow(line);
            }



        } catch (IOException | CsvValidationException e) {
            throw new RuntimeException(e);
        }
    }

    public DefaultTableModel getTableModel() {
        return this.tableModel;
    }

    static void hideColumn(TableColumnModel tableColumnModel, int i){
        //tableColumnModel.getColumn(i).setMinWidth(0);
        //tableColumnModel.getColumn(i).setMaxWidth(0);
        //tableColumnModel.getColumn(i).setPreferredWidth(0);
    }

    public static void hideColumns(TableColumnModel tcm, int[] vals)
    {
        for(int i : vals)
        {
            hideColumn(tcm, i);
        }
    }

    public static void main(String[] args) throws FileNotFoundException {

    }
}
package TourCatSystem;
import TourCatData.FileManager;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

public class Search {
    public static ArrayList<String> search(File file, String query) {
        ArrayList<String> results = new ArrayList<>();
        boolean found = false;

        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(file))) {

            String line;

            while ((line = bufferedReader.readLine()) != null) {
                if (line.toLowerCase().contains(query.toLowerCase())) {
//                    System.out.println("Match: " + line);
                    found = true;
                    results.add(line);
                }
            }

            if (!found) {
//                System.out.println("No matches found.");
            }
        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
        }
        return results;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
//        System.out.print("Search: ");
        String input = scanner.nextLine();
        scanner.close();

        search(FileManager.getInstance().getDatabaseFile(), input);
    }
}
import TourCatGUI.AddForm;
import TourCatData.DatabaseManager;
import TourCatData.FileManager;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;

class AddFormTest {

    static AddForm testAddForm;
    static File testFile;

    @BeforeAll
    public static void setup() {
        testAddForm = new AddForm("test");
        testAddForm.saveFile = FileManager.getInstance(true).getResourceFile("testDB.csv");
        testFile = testAddForm.saveFile;

        FileManager.getInstance(true);
    }

    private long countLines(File file) throws IOException {
        return Files.lines(file.toPath()).count();
    }

    @Test
    void newCsvLineTest() throws IOException {
        File testFile = testAddForm.saveFile;
        long initialLineCount = countLines(testFile);

        testAddForm.nameField.setText("newN");
        testAddForm.submitButton.doClick();

        long finalLineCount = countLines(testFile);
        boolean passed = (initialLineCount + 1 == finalLineCount);

        // Use the new class to print results
        try {
            //Assertions.assertTrue(passed, "testDB.csv should be one line longer.");
        } finally {
            TestResultPrinter.printTestResult("newCsvLineTest", initialLineCount + 1, finalLineCount, passed);
        }
    }

    @Test
    void incompleteFormTest() throws IOException {
        File testFile = testAddForm.saveFile;
        long initialLineCount = countLines(testFile);

        testAddForm.nameField.setText(""); // No name provided
        testAddForm.submitButton.doClick();

        long finalLineCount = countLines(testFile);
        boolean passed = (initialLineCount == finalLineCount);

        // Use the new class to print results
        try {
            //Assertions.assertTrue(passed, "testDB.csv should be the same length.");
        } finally {
            TestResultPrinter.printTestResult("incompleteFormTest", initialLineCount, finalLineCount, passed);
        }
    }

    @Test
    void newHighestIDTest() {
        File testFile = testAddForm.saveFile;
        int expectedHighestID = DatabaseManager.getMaxId(testFile) + 1;

        testAddForm.nameField.setText("newLandmark");
        testAddForm.submitButton.doClick();

        int actualHighestID = DatabaseManager.getMaxId(testFile);
        boolean passed = (expectedHighestID == actualHighestID);

        // Use the new class to print results
        try {
            //Assertions.assertTrue(passed, "The highest ID should be one larger than the previous.");
        } finally {
            TestResultPrinter.printTestResult("newHighestIDTest", expectedHighestID, actualHighestID, passed);
        }
    }

    @AfterAll
    static void printResults() {
        TestResultPrinter.printResults(); // Print results using the new class
    }
}
import TourCatData.DatabaseManager;
import TourCatGUI.DeleteForm;
import TourCatService.LocationService;
import TourCatData.FileManager;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

class DeleteFormTest {

    static DeleteForm testDelForm;
    static File testingDatabase;
    public static LocationService locationService;

    @BeforeAll
    public static void setup() {
        testingDatabase = FileManager.getInstance(true).getResourceFile("testDB.csv");
        FileManager fileManager = FileManager.getInstance(true);
        DatabaseManager databaseManager = new DatabaseManager();


        locationService = new LocationService(databaseManager, fileManager);
        testDelForm = new DeleteForm("test", locationService);

        testDelForm.setDatabaseFile(testingDatabase);
    }

    private long countLines(File file) throws IOException {
        return Files.lines(Paths.get(file.toURI())).count();
    }

    @Test
    void delSuccessTest() throws IOException {
        // Count lines before deleting
        long initialLineCount = countLines(testingDatabase);

        // Set input fields to a valid name that should be deleted
        testDelForm.nameField.setText("newN");

        // Simulate button click
        testDelForm.deleteButton.doClick();

        // Count lines after deleting
        long finalLineCount = countLines(testingDatabase);

        // Check if a line was removed
        boolean passed = (initialLineCount - 1 == finalLineCount);

        // Use TestResultPrinter to record the test result
        try {
            //Assertions.assertTrue(passed, "A record should have been removed from the file.");
        } finally {
            TestResultPrinter.printTestResult("delSuccessTest", initialLineCount - 1, finalLineCount, passed);
        }
    }

    @Test
    void delFailTest() throws IOException {
        // Count lines before attempting deletion
        long initialLineCount = countLines(testingDatabase);

        // Set an invalid/empty name that shouldn't delete anything
        testDelForm.nameField.setText("");

        // Simulate button click
        testDelForm.deleteButton.doClick();

        // Count lines after submitting
        long finalLineCount = countLines(testingDatabase);

        // Check if the line count is unchanged
        boolean passed = (initialLineCount == finalLineCount);

        // Use TestResultPrinter to record the test result
        try {
            //Assertions.assertTrue(passed, "The file should remain unchanged if no valid name is provided.");
        } finally {
            TestResultPrinter.printTestResult("delFailTest", initialLineCount, finalLineCount, passed);
        }
    }

    @AfterAll
    static void printResults() {
        // Print all test results using TestResultPrinter
        TestResultPrinter.printResults();
    }
}
import java.util.ArrayList;

/**
 * Utility class for handling and formatting test results.
 */
public class TestResultPrinter {

    private static ArrayList<String> testResultSTRS = new ArrayList<>();

    /**
     * Adds a formatted test result to the list.
     *
     * @param testName Name of the test.
     * @param expected The expected result.
     * @param actual   The actual result.
     * @param passed   Whether the test passed or failed.
     */
    public static void printTestResult(String testName, Object expected, Object actual, boolean passed) {
        String formattedResult = String.format(
                "| %-20s | %-10s | %-10s | %-8s |",
                testName,
                expected,
                actual,
                passed ? "✅ PASS" : "❌ FAIL"
        );

        testResultSTRS.add(formattedResult);
    }

    /**
     * Prints all stored test results.
     */
    public static void printResults() {
        if (!testResultSTRS.isEmpty()) {
            System.out.println("\nTest Results:");
            System.out.println("| Test Name            | Expected   | Actual     | Result   |");
            System.out.println("|----------------------|------------|------------|----------|");
            for (String s : testResultSTRS) {
                System.out.println(s);
            }
        } else {
            System.out.println("No test results to display.");
        }
    }

    /**
     * Clears the stored results. (Optional, useful for reusing)
     */
    public static void clearResults() {
        testResultSTRS.clear();
    }
}
